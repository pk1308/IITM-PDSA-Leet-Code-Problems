<!doctype html>
<html lang="en">

<head>
        <title>Leet Code Problems on Graph Algorithms - DBMS</title>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        
        
        <meta name="author" content="PK">

        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
            <link rel="stylesheet" href="../../assets/css/darcula-highlight.min.css">

        <link rel="stylesheet" href="../../assets/css/bootstrap.min.css">
        <link rel="stylesheet" href="../../assets/css/dracula-ui.min.css">
        <link rel="stylesheet" href="../../assets/css/mkdocs.min.css">

        
            <link  rel="icon" type="image/x-icon" href="../../assets/img/favicon.ico">
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
                <script>hljs.initHighlightingOnLoad();</script>

</head>

<body class="drac-bg-black-secondary drac-text-grey-ternary drac-text drac-scrollbar-purple">

    <main class="d-flex">

        <!-- block sidebar -->
            <nav id="sidebar" class="sidebar drac-bg-black">
    <div class="custom-menu">
        <button type="button" id="sidebarCollapse" class="btn btn-primary">
            <i class="fa fa-bars"></i>
            <span class="sr-only">Menu</span>
        </button>
    </div>

    <div class="p-4">
        

        <div class="drac-text-center">
            
                <span class="drac-text drac-line-height drac-text-white">DBMS</span>
            
        </div>

        <div class="drac-box flex-column">
            <ul class="dot-ul">
                <li><div class="dot-li drac-bg-cyan"></div></li>
                <li><div class="dot-li drac-bg-green"></div></li>
                <li><div class="dot-li drac-bg-orange"></div></li>
                <li><div class="dot-li drac-bg-pink"></div></li>
                <li><div class="dot-li drac-bg-purple"></div></li>
                <li><div class="dot-li drac-bg-red"></div></li>
                <li><div class="dot-li drac-bg-yellow"></div></li>
            </ul>
        </div>

        <hr class="drac-divider" />

        <!-- block menu -->
        <ul class="mb-5 drac-list drac-list-none">
            
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
                    Home
                </a>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#greedy-collapse" aria-expanded="false">
                    Greedy
                </a>
                <div class="collapse" id="greedy-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../Greedy/Questions/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Problems on Greedy Algorithms
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#heaps-and-trees-collapse" aria-expanded="false">
                    Heaps and Trees
                </a>
                <div class="collapse" id="heaps-and-trees-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../Heaps%20and%20Trees/Questions/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Leet Code Problems on Heaps and Trees
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class=" active 
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#graphs-bfs,-dfs,-topological-sorting-collapse" aria-expanded="false">
                    Graphs-BFS, DFS, Topological Sorting
                </a>
                <div class="collapse" id="graphs-bfs,-dfs,-topological-sorting-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="./"
            class=" active 
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Leet Code Problems on Graph Algorithms
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#arrays,-lists,-stacks,-queues,-hashing-collapse" aria-expanded="false">
                    Arrays, Lists, Stacks, Queues, Hashing
                </a>
                <div class="collapse" id="arrays,-lists,-stacks,-queues,-hashing-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Leet Code Problems on Arrays, Lists, Stacks, Queues, and Hashing
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#sorting-and-searching-collapse" aria-expanded="false">
                    Sorting and Searching
                </a>
                <div class="collapse" id="sorting-and-searching-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../Sorting%20and%20Searching/Questions/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Problems on Sorting and Searching
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#shortest-paths-and-minimum-spanning-trees-collapse" aria-expanded="false">
                    Shortest Paths and Minimum Spanning Trees
                </a>
                <div class="collapse" id="shortest-paths-and-minimum-spanning-trees-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../Shortest%20Paths%20and%20Minimum%20Spanning%20Trees/Questions/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Leet Code Problems on Shortest Path and Minimum Cost Spanning Trees
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#dynamic-programming-collapse" aria-expanded="false">
                    Dynamic Programming
                </a>
                <div class="collapse" id="dynamic-programming-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../Dynamic%20Programming/Questions/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Leet Code Problems Based on Dynamic Programming
        </a>
    </li>
                    </ul>
                </div>
            </li>
        </ul>
        <!-- endblock -->
    </div>
</nav>
        <!-- endblock -->

        <nav class="divider drac-bg-purple-cyan"></nav>

        <div class="content">
            <!-- block header -->
                <header>
    <nav class="navbar navbar-expand-xl drac-bg-purple">
        <div class="container-fluid">
            
            <button class="navbar-toggler w-100 text-center" type="button" data-bs-toggle="collapse" data-bs-target="#navbarsMenu"
                aria-controls="navbarsMenu" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse flex-column ml-auto" id="navbarsMenu">
                <ul class="navbar-nav text-md-center">

                    <!-- block preview -->
                    <li class="nav-item">
                            
        <div class="container">
            <div class="row row-preview">
                <div class="col">
                    <a href="../../Heaps%20and%20Trees/Questions/"
                        class="btn-preview drac-btn drac-btn-outline drac-text-white drac-text-cyan-green--hover">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </div>
                <div class="col">
                    <a href="../../Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/"
                        class="btn-preview drac-btn drac-btn-outline drac-text-white drac-text-cyan-green--hover" style="padding-left: 3%;">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </div>
            </div>
        </div>
                    </li>
                    <!--  endblock -->

                    <!-- block search -->
                    <li class="nav-item"><div role="search" class="search-box">
	<form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
		<input type="text" name="q" class="drac-input drac-input-search drac-input-white drac-text-white drac-bg-black-secondary"
		placeholder="Search docs" title="Type search term here" />
	</form>
</div>
                    </li>
                    <!--  endblock -->

                    <!-- block source -->
                    <li class="nav-item">
                        
                            
                                <div class="md-source source-detail">
    <div class="md-source-repo-icon">
        <i class="fa fa-github-alt drac-text-white" aria-hidden="true"></i>
    </div>

    <div class="md-source-repo-url">
        <a href="https://github.com/pk1308/DBMS"
            class="md-source drac-anchor drac-text drac-text-white drac-text-cyan-green--hover">
            pk1308/DBMS
        </a>

        <ul class="md-source-repo-text">
            <li>
                <i class="fa fa-tag drac-text-black" aria-hidden="true"></i>
                <img alt="GitHub tag (latest by date)"
                    src="https://img.shields.io/github/v/tag/pk1308/DBMS?color=white&label=%20&style=flat-square">
            </li>

            <li>
                <i class="fa fa-star drac-text-black" aria-hidden="true"></i>
                <img alt="GitHub Repo stars"
                    src="https://img.shields.io/github/stars/pk1308/DBMS?color=white&label=%20&style=flat-square">
            </li>

            <li>
                <i class="fa fa-code-fork drac-text-black" aria-hidden="true"></i>
                <img alt="GitHub forks"
                    src="https://img.shields.io/github/forks/pk1308/DBMS?color=white&label=%20&style=flat-square">
            </li>
        </ul>
    </div>

</div>
                            
                        
                    </li>
                    <!--  endblock -->

                </ul>
            </div>

        </div>
    </nav>
</header>
            <!-- endblock -->

            <!-- block content -->
                <section class="p-md-5 section-content">
    <article>
        <p><div><h1 id="leet-code-problems-on-graph-algorithms">Leet Code Problems on Graph Algorithms</h1>
<h5 id="1-find-the-town-judge">1. <a href="#1-find-the-town-judge-1">Find the Town Judge</a></h5>
<h5 id="2-course-schedule-i">2. <a href="#2-course-schedule-i">Course Schedule-I</a></h5>
<h5 id="3-course-schedule-ii">3. <a href="#3-course-schedule-ii-1">Course Schedule-II</a></h5>
<h5 id="4-snakes-and-ladders">4. <a href="#4-snakes-and-ladders-1">Snakes and Ladders</a></h5>
<h5 id="5-sort-items-by-groups-respecting-dependencies">5. <a href="#5-sort-items-by-groups-respecting-dependencies-1">Sort Items By Groups Respecting Dependencies</a></h5>
<h5 id="6-find-if-path-exists">6. <a href="#6-find-if-path-exists-1">Find If Path Exists</a></h5>
<h5 id="7-number-of-provinces">7. <a href="#7-number-of-provinces-1">Number of Provinces</a></h5>
<h2 id="1-find-the-town-judge_1">1. <a href="https://leetcode.com/problems/find-the-town-judge/description/">Find the Town Judge</a></h2>
<h3 id="11-by-counting-indegrees">1.1 By Counting Indegrees</h3>
<p>We're given the array <code>trusts</code>, where <code>trust[i] = [a_i, b_i]</code> means that <code>a_i_</code> trusts <code>b_i_</code>. Can we convert this problem into a graph problem?</p>
<p>If <code>a_i_</code> trusts <code>b_i_</code>, then we can consider it an edge from <code>a_i_</code> to <code>b_i_</code>. </p>
<p>The townjudge is a person who:
- Trusts no one <span class="arithmatex">\(\implies outdegree(townjudge) = 0\)</span> , and
- Everyone except him / herself trusts him / her <span class="arithmatex">\(\implies indegree(townjudge) = n - 1\)</span>.</p>
<p>Keep two dictionaries:
- To count the indegrees of all the nodes
- To count the outdegrees of all the nodes</p>
<p>Then for every person, check if its outdegree is <span class="arithmatex">\(0\)</span> and indegree is <span class="arithmatex">\(n-1\)</span>.</p>
<p>Complexity: <span class="arithmatex">\(O(n)\)</span>, since the creating the dictionaries takes <span class="arithmatex">\(O(n)\)</span> and then iterating over people takes another <span class="arithmatex">\(O(n)\)</span>.</p>
<h4 id="code">Code:</h4>
<pre class="highlight"><code>class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -&gt; int:        
        if n &lt;= 1:
            return 1

        indegrees = { }
        outdegrees = { }

        # trust = [a_i, b_i]
        # a_i -&gt; b_i
        for a, b in trust:
            if a not in indegrees: indegrees[a] = 0
            if b not in indegrees: indegrees[b] = 0
            if a not in outdegrees: outdegrees[a] = 0
            if b not in outdegrees: outdegrees[b] = 0

            outdegrees[a] += 1
            indegrees[b] += 1

        # If indegree == n - 1 and outdegree == 0, then we have found the town judge.
        townjudge = -1
        for person in indegrees:
            if outdegrees[person] == 0:
                if indegrees[person] &gt;= n - 1:
                    townjudge = person 
                    break
        return townjudge        </code></pre>
<h2 id="2-course-schedule-i_1">2. <a href="https://leetcode.com/problems/course-schedule/description/">Course Schedule-I</a></h2>
<h3 id="21-topological-sorting">2.1 Topological Sorting</h3>
<p>The <code>prerequisites[i] = [a_i, b_i]</code> <span class="arithmatex">\(\implies\)</span> <code>b_i</code> has to come before <code>a_i</code>. In other words, <code>a_i</code> is dependent on <code>b_i</code>. Can you convert this problem into a graph problem? Further, which algorithm do we need to use to find a sequence that satisfies dependencies?</p>
<p>If <code>b_i</code> has to come before <code>a_i</code>, then we add an edge from <code>b_i</code> to <code>a_i</code>. Please note the direction of the edge. We can convert this into an adjacency matrix or an adjacency list. For this problem, we are converting the graph into an adjacency matrix. Once we have converted this problem into a graph problem, we can use the algorithm we use when we need to find a sequence that satisfies some dependencies- topological sorting.</p>
<p>When would you say that we have successfully found the sequence of courses satisfying the dependencies? 
When we the sequence that we get has all the courses- no course is left.  </p>
<h4 id="code_1">Code:</h4>
<pre class="highlight"><code>class Solution:
    def preprocessing(self, numCourses, prerequisites) -&gt; list[list[int]]:
        adjacency_matrix = [ [0 for i in range(numCourses)] for i in range(numCourses) ]
        for a, b in prerequisites:
            adjacency_matrix[b][a] = 1
        return adjacency_matrix

    # Implementation of Topological sort for Adjacency matrix
    def toposort(self, AMat):
        #Initialization
        (rows,cols) = len(AMat), len(AMat[0])
        indegree = {}
        toposortlist = []

        #Compute indegree for each vertex
        for c in range(cols):
            indegree[c] = 0
            for r in range(rows):
                if AMat[r][c] == 1:
                    indegree[c] = indegree[c] + 1

        # Topological sort Computing process
        for i in range(rows):
            # Select the min level vertex for removing the graph which has indegree 0
            zero_indegree = [k for k in range(cols) if indegree[k] == 0]
            if not zero_indegree:return toposortlist #Handle the case where there are no more zero indegree vertices

            j = zero_indegree[0]
            # Store the removed vertex j in toposortlist and reduce the indegree by one 
            toposortlist.append(j)
            indegree[j] = indegree[j] - 1

            # Reduce the indegree of each adjacent of the removed vertex j by 1
            for k in range(cols):
                if AMat[j][k] == 1:
                    indegree[k] = indegree[k] - 1

        return(toposortlist)

    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:
        adjacency_matrix = self.preprocessing(numCourses, prerequisites)
        toposortlist = self.toposort(adjacency_matrix)
        if len(toposortlist) == numCourses: return True
        return False
</code></pre>
<h3 id="22-topological-sort-better-implementation">2.2 Topological Sort: Better Implementation</h3>
<p>The approach used is similar to the above approach. However, we are utilizing better data structures to increase our performance. Instead of keeping an adjacency matrix, we are utilizing a combination of doubly ended queues and adjacency lists. </p>
<p>Here's how:
- Keep a deque for vertices with zero degree queue such that the insert at end and delete from start operations are both constant time.
- Keep a dictionary of indegrees which counts the indegrees for each vertex</p>
<p>Complexity: $O(|V| + |E|)</p>
<h4 id="code_2">Code:</h4>
<pre class="highlight"><code>from collections import deque, Counter

class Solution:
    def canFinish(self, numCourse, prerequisites):
        AList = { i: [] for i in range(numCourse)}
        indegree = Counter()
        visited = { i:False for i in range(numCourse)}

        for course, prereq in prerequisites:
            AList[prereq].append(course)
            indegree[course] += 1

        # Initialization
        toposortlist = []
        zerodegreeq = deque()

        # Find the vertex with indegree 0 and added into the queue
        for u in range(numCourse):
            if indegree[u] == 0:
                zerodegreeq.append(u)

        # Topological sort Computing process
        while (zerodegreeq):
            # Remove one vertex from queue which have zero degree vertices
            curr_vertex = zerodegreeq.popleft()       
            # Store the removed vertex in toposortlist and reduce the indegree by one 
            toposortlist.append(curr_vertex)
            indegree[curr_vertex] = indegree[curr_vertex]-1

            # Repeat for each adjacent of the removed vertex
            for adj_vertex in AList[curr_vertex]:
                # Reduce the indegree of each adjacent of the removed vertex by 1
                indegree[adj_vertex] = indegree[adj_vertex] - 1
                # If after reducing the degree of adjacent, it becomes zero then insert it into the queue
                if indegree[adj_vertex] == 0:
                    zerodegreeq.append(adj_vertex)                

        return len(toposortlist) == numCourse</code></pre>
<h2 id="3-course-schedule-ii_1">3. <a href="https://leetcode.com/problems/course-schedule-ii/description/">Course Schedule-II</a></h2>
<p>This problem is an exact replica of the above problem, except that we have to return a sequence that satisfies the dependencies, instead of returning a boolean of whether or not we can create such a sequence. </p>
<p>We can use the same approaches discussed in the above question. </p>
<h2 id="4-snakes-and-ladders_1">4. <a href="https://leetcode.com/problems/snakes-and-ladders/description/">Snakes and Ladders</a></h2>
<h3 id="41-using-bfs">4.1 Using BFS</h3>
<p>We are given a board with <span class="arithmatex">\(n^2\)</span> cells. From any particular cell, there can be at maximum only six moves. Can we convert this structure into a graph?</p>
<p>For example, in the first test case, assume we are at cell <span class="arithmatex">\(1\)</span>. </p>
<p>The next possible moves are: <span class="arithmatex">\(15, 3, 4, 5, 6, 7\)</span> because <span class="arithmatex">\(2\)</span> has a ladder to <span class="arithmatex">\(15\)</span>. 
From cell <span class="arithmatex">\(1\)</span>, we can make each of the next possible moves as an edge.</p>
<p>The task is to find the least number of moves required to reach <span class="arithmatex">\(n^2\)</span> starting from <span class="arithmatex">\(1\)</span>. Can you identify what type of a problem this is and which algorithm we can use for this problem?</p>
<p>It's a shortest path problem without edge weights. The algorithm that we can use for this problem is BFS. </p>
<p>Pseudocode:
- We first need to convert the board into a graph. 
    - For every cell, check the next six cells. 
        - If the cell has a ladder or a snake, then we need to find out where the ladder ends which is given in cell: <code>board[row][col]</code>
        - If the cell does not have a ladder or a snake, then <code>board[row][col]</code> will have the vaue <span class="arithmatex">\(-1\)</span>. 
        - Add the edge as: <code>[cell]</code> to <code>board[row][cell]</code> or the next moves.</p>
<ul>
<li>Once we have the graph, we can run BFS on this graph, which will return the shortest path. </li>
</ul>
<h4 id="code_3">Code:</h4>
<h2 id="5-sort-items-by-groups-respecting-dependencies_1">5. <a href="https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/description/">Sort Items By Groups Respecting Dependencies</a></h2>
<h3 id="51-using-topological-sort">5.1 Using Topological Sort</h3>
<p>We need to list a a sequential order of <code>items</code> such that the items belonging to the same group are listed next to each other. Each item can have a dependency such that the other item needs to be completed first- as given in the <code>beforeItems</code> array. It is easy to see that this is a topological ordering problem. </p>
<p>Take a moment to think about the following:
Let's say we run topological sort directly on the beforeItems. We may pass some test cases. But what test cases might we fail?
Whenever we have multiple <code>items</code> that have zero indegree, then we have to make a choice as to which item should we take first. Let's take an example: 
</p><pre class="highlight"><code>group[0] = [1, 2]
group[1] = [3, 4]
indegree[1] = 0
indegree[3] = 0
indegree[2] = indegree[4] = 1 

Assume: 2 needs to be come before 4, and 1 needs to come before 2. 
1 -&gt; 2 -&gt; 4</code></pre>
<p>Now, the issue will come when we are selecting between the <code>items</code> 1 and 3. If our algorithm chooses 3, then all the other elements belonging to group 1 should come next to 3- like: 3, 4-, and only then we'll be able to add elements from group 0- like: 3, 4, 1, 2. This violates the condition that <code>1 -&gt; 2 -&gt; 4</code>.</p>
<p>To solve this problem, we need to keep a graph for the <code>groups</code> as well. Whenever we are choosing which <code>item</code> to select for the topological order, we need to first check the <code>groups</code> graph. </p>
<p>Thus, we keep two graphs- one for <code>items</code> and one for <code>groups</code>. Then we run a sort of nested topological sort- the outer one for the <code>groups</code> graph, and the inner one for the <code>items</code> graph. This will give us the correct solution that respects both the group dependencies and the item dependencies. </p>
<h4 id="psuedocode">Psuedocode:</h4>
<ol>
<li>
<p>Since we are going to need to list all elements belonging to a group side by side, we will keep a dictionary of the format: <code>group:[all items of that group]</code> for easy retrieval.</p>
</li>
<li>
<p>Use <code>beforeItems</code> array to construct both the graphs- <code>groups</code> and <code>items</code>. You can use the either an adjacency matrix or an adjacency list representation for this. Here, we are using Adjacency List representation. </p>
<ul>
<li>If <code>items[i]</code> needs to come before <code>items[j]</code>, then add edge from <code>i</code> to <code>j</code> for the <code>items_graph</code>. </li>
<li>Similarly, for the <code>group_graph</code>, add the edge from <code>group[i]</code> to <code>group[j]</code>, since the item in <code>i</code>th group needs to come before the item in the <code>j</code>th group. </li>
</ul>
</li>
<li>
<p>Once you have the graphs, run nested topological sort as mentioned above. </p>
</li>
</ol>
<h4 id="code_4">Code:</h4>
<pre class="highlight"><code># Implementation of Queue
class Queue:
    def __init__(self):
        self.queue = []
    def enqueue(self,v):
        self.queue.append(v)
    def isempty(self):
        return(self.queue == [])
    def dequeue(self):
        v = None
        if not self.isempty():
            v = self.queue[0]
            self.queue = self.queue[1:]
        return(v)    
    def __str__(self):
        return(str(self.queue))

class Solution:
    # Creates a dictionary that returns all elements of a particular group. Used in the main algorithm when we are listing all the items # that belong to a group side by side
    def get_group_wise_elements(self, group, m):
        group_wise_elements = { i:[] for i in range(m) }
        for i in range(len(group)):
            grp = group[i] if group[i] &gt;= 0 else -i-1
            if grp not in group_wise_elements:
                group_wise_elements[grp] = []
            group_wise_elements[grp].append(i)
        return group_wise_elements

    # Convert the problem into two graphs- group_graph and items_graph. Along with it, return indegrees for each node in both the graphs. 
    def preprocessing(self, beforeItems, group, m, n, groupwise_items):
        group_indegree, items_indegree = {}, {i:0 for i in range(n)}
        items_alist =  {i:[] for i in range(n)}
        group_alist = {}

        for key in groupwise_items:
            group_alist[key] = set()
            group_indegree[key] = 0

        for i in range(len(beforeItems)):
            before = beforeItems[i]
            for num in before:
                if num not in items_alist:
                    items_alist[num] = [ ]
                items_alist[num].append(i)
                items_indegree[i] += 1

                grp_num = group[num] if group[num] &gt;= 0 else -num-1
                grp_i = group[i] if group[i] &gt;= 0 else -i-1  
                if grp_num != grp_i:
                    if grp_num not in group_alist:
                        group_alist[grp_num] = set()
                    group_alist[grp_num].add(grp_i)

        for key in group_alist.keys():
            group_alist[key] = list(group_alist[key])

        for u in group_alist.keys():
            for v in group_alist[u]:
                if v not in group_indegree:
                    group_indegree[v] = 0
                group_indegree[v] += 1

        return items_alist, group_alist, items_indegree, group_indegree

    # Run the actual nested topological sorting algorithm
    def lpath(self, items_alist, group_alist, items_indegree, group_indegree, groupwise_items, n, group):
        output = [ ]

        grp_queue = Queue()
        items_queue = Queue()

        for grp in group_indegree:
            if group_indegree[grp] == 0:
                grp_queue.enqueue(grp)

        # Outer topological sort is for groups
        while not grp_queue.isempty():
            curr_grp = grp_queue.dequeue()
            group_indegree[curr_grp] -= 1
            for adj_grp in group_alist[curr_grp]:
                # Reduce the indegree of each adjacent group of the removed vertex by 1
                group_indegree[adj_grp] -= 1

                # If after reducing the degree of adjacent group, it becomes zero then insert it into the group queue
                if group_indegree[adj_grp] == 0 :
                    grp_queue.enqueue(adj_grp)

            for i in groupwise_items[curr_grp]:
                if items_indegree[i] == 0 :
                    items_queue.enqueue(i)

            # Inner topological sort is for the items
            while (not items_queue.isempty()):

                # Remove one vertex from items queue which have zero degree items and reduce the indegree by 1
                curr_vertex = items_queue.dequeue()
                output.append(curr_vertex)
                items_indegree[curr_vertex] = items_indegree[curr_vertex] - 1

                # Repeat for each adjacent of the removed item 
                for adj_vertex in items_alist[curr_vertex]:
                    # Reduce the indegree of each adjacent of the removed item by 1
                    items_indegree[adj_vertex] = items_indegree[adj_vertex] - 1

                    # If after reducing the degree of adjacent item, it becomes zero then insert it into the items queue
                    if items_indegree[adj_vertex] == 0 and group[adj_vertex] == curr_grp:
                        items_queue.enqueue(adj_vertex)

        if len(output) != n: return []
        return output

    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -&gt; List[int]:
        group_wise_items = self.get_group_wise_elements(group, m)

        items_alist, group_alist, items_indegree, group_indegree = self.preprocessing(beforeItems,group, m, n, group_wise_items)

        return self.lpath(items_alist, group_alist, items_indegree, group_indegree, group_wise_items, n, group)</code></pre>
<h2 id="6-find-if-path-exists_1">6. <a href="https://leetcode.com/problems/find-if-path-exists-in-graph/description/">Find If Path Exists</a></h2>
<h3 id="61-using-bfs">6.1 Using BFS</h3>
<p>What is the question asking you to do?
- We need to find out whether we can reach a particular destination from the given source node. That is, it's a reachability problem. </p>
<p>Can you convert the given <code>edges</code> list into an adjacency list or an adjacency matrix representation?
- Each <code>edges[i] = [u_i, v_i]</code> represents a bidirectional edge, which means there is an edge from <code>u</code> to <code>v</code>, and <code>v</code> to <code>u</code>. 
- So we can iterate over the entire <code>edges</code> array, and add the two edges for every <code>edges[i]</code>. Here's the code snippet for converting the <code>edges</code> array into an adjacency list:
</p><pre class="highlight"><code>for u, v in edges:
    adj_list[u].append(v)
    adj_list[v].append(u)</code></pre>
<p>Once we have the adjacency list, which algorithm will give us whether we can reach <code>destination</code> from the <code>source</code>?
- We can use either BFS or DFS. For this solution, we are using BFS. </p>
<h4 id="code_5">Code:</h4>
<p>Note: For a better, more concise code, we have used the <code>deque</code> data structure from the <code>collections</code> module in Python. We can use it to implement a <code>queue</code> used in BFS. </p>
<pre class="highlight"><code>from collections import deque

class Solution:
    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -&gt; bool:
        adj_list = { i:[ ] for i in range(n) }
        visited = set()
        for u, v in edges:
            adj_list[u].append(v)
            adj_list[v].append(u)

        queue = deque([source])
        visited.add(source)
        while queue:
            vertex = queue.popleft()
            if vertex == destination:
                return True
            for neighbor in adj_list[vertex]:
                if neighbor not in visited:
                    queue.append(neighbor)
                    visited.add(neighbor)
        return False</code></pre>
<h2 id="7-number-of-provinces_1">7. <a href="https://leetcode.com/problems/number-of-provinces/description/">Number of Provinces</a></h2>
<h3 id="71-using-bfs">7.1 Using BFS</h3>
<p>We are given a matrix <code>isConnected</code>, whose <code>[i][j]</code>th entry tells us whether there is an undirected edge from <code>i</code> to <code>j</code>. We can interpret this <code>isConnected</code> matrix as an adjacency matrix. </p>
<p>A province is a set of vertices that are connected to each other. We are asked to find the number of provinces from the matrix. </p>
<p>Can you identify the type of the problem?
- The problem is about finding the number of connected components from the graph. </p>
<p>Can you identify which algorithm we can use to solve this problem?
- We can use BFS or DFS to solve this problem. For this solution, we will use BFS. </p>
<h4 id="code_6">Code:</h4>
<pre class="highlight"><code>from collections import deque

class Solution:
    def get_neighbors(self, AMat, vertex):
        """Given an adjacency matrix and a vertex, returns all neighbors for that vertex"""
        neighbors = []
        for i in range(len(AMat)):
            if AMat[vertex][i] == 1:
                neighbors.append(i)
        return neighbors

    def BFS(self, AMat, source):
        """
        Runs BFS from a given source vertex and returns the set of vertices visited in that run of BFS.
        That is, each run of the BFS will give us one province, or one connected component.
        """
        visited = set()
        queue = deque([source])  # Initialize the queue with the source vertex
        visited.add(source)
        while queue:
            vertex = queue.popleft()
            neighbors = self.get_neighbors(AMat, vertex)  # Pass both AMat and vertex
            for neighbor in neighbors:
                if neighbor not in visited:
                    queue.append(neighbor)
                    visited.add(neighbor)
        return visited

    def findCircleNum(self, isConnected):

        # Initially, every vertex gets an invalid component number
        components = {i: -1 for i in range(len(isConnected))}

        # Keep track of the component number and the number of vertices already visited across BFS runs
        component_number = 0
        seen = 0

        while seen &lt; len(isConnected):
            startv = min([i for i in range(len(isConnected)) if components[i] == -1])
            visited = self.BFS(isConnected, startv)

            # For every vertex that was visited in the current run of BFS, update its component number and update 
            # the number of vertices seen.
            for v in visited:
                components[v] = component_number
                seen += 1

            # Increment component number such that for the next run of BFS, 
            # a different component number will be assigned
            component_number += 1

        return component_number </code></pre></div></p>
    </article>
</section>
            <!-- endblock -->

            <!-- block footer -->
                <footer>
    <div class="d-flex flex-sm-row justify-content-between py-2 border-top drac-text-black drac-bg-cyan-green">
        <a href="https://github.com/dracula/mkdocs" target="_blank" style="padding-left: 1%;"
            class="footer-text drac-anchor drac-text-black drac-text-purple--hover">
            Made with Dracula Theme for MkDocs
        </a>
    </div>
</footer>
            <!-- endblock -->
        </div>

    </main>

        <script>var base_url = '../..';</script>
        <script src="../../assets/js/jquery-3.3.1.slim.min.js"></script>
        <script src="../../assets/js/bootstrap.bundle.min.js"></script>
        <script src="../../assets/js/mkdocs.js"></script>
			<script src="../../javascripts/mathjax.js" defer></script>
			<script src="https://polyfill.io/v3/polyfill.min.js" defer></script>
			<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" defer></script>
			<script src="../../search/main.js" defer></script>

</body>

</html>