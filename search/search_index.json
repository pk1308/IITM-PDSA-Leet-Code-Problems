{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/","text":"Leet Code Problems on Arrays, Lists, Stacks, Queues, and Hashing \ud83d\udccb Table of Contents: 1. Valid Parentheses 2. Longest Consecutive Sequence 3. Rotate List 4. Swap Nodes in Pairs 5. Reverse Nodes in K Groups 6. Middle of The Linked List 7. Delete the Middle Node 8. Delete nth Node From End 9. Merge Two Sorted Lists 1. Valid Parentheses 1.1 Using Stacks \ud83d\udd0d Problem Understanding: There are only three types of brackets: [], (), {} . We need to close the last opened bracket first. This implies a Last In, First Out (LIFO) system. Can you think of the appropriate data structure here? Since LIFO behavior is required, a stack is perfect for tracking the parentheses. As we encounter opening parentheses, we add them to the stack. When we see a closing bracket, we remove (pop) the last added one. \ud83e\udd14 Think about this: Imagine you've processed the first two characters of the string and added them to the stack. Your stack might look like this: stack = ['(', '{']. Now, suppose the next character is }. How do you check if this closing bracket matches the last opened one? We can maintain a mapping like this: \\ closing bracket : its corresponding opening bracket . This allows us to verify that each closing bracket properly matches its corresponding opening one. \u26a0\ufe0f Edge Cases: What if there are opening brackets left in the stack, but no more characters in the string? Or vice versa\u2014what if there are closing brackets in the string, but no opening ones left in the stack? Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\) \ud83d\udcbb Code Implementation:: class Solution: def isValid(self, s: str) -> bool: # Keep the mapping as 'closing bracket' : 'Correspoding opening bracket' mapping = { ')' : '(', ']' : '[', '}' : '{' } stack = [ ] # O(n) for char in s: if char not in mapping: # This means that the bracket is an open bracket stack.append(char) # Simply add the open bracket to the stack else: # Corner case- stack has no elements but the string has closing bracket if len(stack) == 0: return False # Check if opening bracket in the stack matches with the closing bracket in the string if mapping[char] != stack.pop(): return False # if stack is empty after checking every char of string # that means that we found the closing bracket for every opening bracket. Thus, return True # And vice versa. Return False return not stack # Returns True if stack is empty, False otherwise 2. Longest Consecutive Sequence 2.1 Brute Force For every element, iterate over the array to check if the next element exists in the array. Keep doing this as long as the next element is found. Keep a counter for each sequence, and track the maximum. Time Complexity: \\(O(n^2)\\) . But we are told to find an \\(O(n)\\) solution! 2.2 Improved Approach Using Sets \ud83e\udde0 Deep Dive: In the brute-force approach, we had to iterate through the entire unsorted array to check if the next element existed. Is there a way to optimize this check? Hint : Consider using a data structure that allows constant-time lookups. We can use set data structure to serve this purpose! How would you solve this using sets? - For each number, while the next consecutive number exists, keep counting. - However, if we use this method directly, some numbers may be checked more than once, leading to \\(O(n^2)\\) time complexity. Can we do better? Which numbers can start a consecutive sequence? - Only those numbers n where n-1 is not in the set. Only these numbers can be the starting points of the longest consecutive sequence. Can you see why? - By finding these starting points, we can run our loop efficiently on only these elements. - Time Complexity: \\(O(n)\\) - Space Complexity: \\(O(n)\\) Code: class Solution: def longestConsecutive(self, nums: List[int]) -> int: # Convert nums to a set num_set = set(nums) starting_points = set() # Only those elements can be starting points where n - 1 is not in num_set # O(n) for num in nums: if num - 1 not in num_set: starting_points.add(num) max_length = 0 # Overall O(n), because the inner while loop is just going to run once for other elements for current_num in starting_points: current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length 3. Rotate List 3.1 \ud83d\udd04 Rotation Logic: If \\(k \\gt n\\) , then the number of effective rotations is: \\(k = k \\mod n\\) . Think about this as a three step problem: First, traverse \\(k\\) nodes. This n - k th node becomes the newhead of the rotated list. Next, connect the original list's tail to its head to create a cycle in the linked list. Finally, walk from the newhead for n nodes to find the newtail , which will become the tail of the rotated list by marking its next pointer as None. \ud83d\udcbb Code Implementation:: class Solution: # Gets the length of node: 'n' def get_length(self, head): current = head count = 0 while current: current = current.next count += 1 return count def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]: n = self.get_length(head) # Corner case if n <= 1: return head k = k % n # Number of effective rotations # In the original list, you need to walk these many steps to get to new head walk_these_many_steps = n - k if k == 0 or walk_these_many_steps == 0: return head # Get the new head of the list that you will get after you rotate current = head count = 0 newhead = None while current: if count == walk_these_many_steps: newhead = current break current = current.next count += 1 # Get to the end of the list so that you can link tail with the head. # But now your linked list is a cycle current = head count = 0 while current: if not current.next: current.next = head break current = current.next # Now you need to make the new tail point to None to break the cycle current = newhead count = 0 while current and count < n: current = current.next count += 1 if count == n - 1: current.next = None return newhead 4. Swap Nodes in Pairs 5. Reverse Nodes in K Groups 5.1 Using Recursion We know how to reverse a linked list from the Graded Assignment question. Given k, we can reverse the first k nodes and return the head and tail of the reversed portion. For the next k nodes, you can pass the kth_node.next as the head and reverse the subsequent k nodes, returning their head and tail. This way, you reverse groups of k nodes. But how do you connect these groups? \ud83e\udd14 Can you think of a recursive way? - Remember that the last reversed k nodes will be the first to return! - Let's take an example list: 1 -> 2 -> 3 -> 4 , and k = 2 . - First, reverse 1 -> 2 as 2 -> 1 , and return the head as 2 and tail as 1 . - Then, reverse 3 -> 4 recursively as 4 -> 3 , and return the head as 4 and tail as 3 . - Now, Now, you just need to connect the tail of the first reversed group (1) to the head of the second reversed group (4). Voil\u00e0! You've connected the reversed groups. Code: class Solution: # Helper function: returns the number of nodes in the linked list def get_length(self, head): count = 0 current = head while current: current = current.next count += 1 return count def reverse(self, head, k, n): if not head: return head, None # If k > n, then remaining nodes should remain as they are if k > n: return head, None # Reverse the K nodes in groups current = head prev = None next_node = None count = 0 while current and count <= k: # Counting because we want to mark the tail also if count < k: next_node = current.next current.next = prev prev = current current = next_node count += 1 curr_head = prev # The head of the reversed k nodes curr_tail = head # tail of the reversed k nodes # Recursively call reverse on the next k nodes next_head, next_tail = self.reverse(next_node, k, n - k) # Connect the current group's tail with the head of the next group curr_tail.next = next_head return curr_head, curr_tail def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]: n = self.get_length(head) head, tail = self.reverse(head, k, n) return head 6. Middle of The Linked List 6.1 Using Iteration How do we find the middle element in an array? We typically compute the middle index as: mid = len(L) // 2 and then return L[mid] . Can you find out a similar approach in linked lists? Let's explore this: First, iterate over the entire list to determine its length. Next, compute the middle index. Finally, traverse the list up to the middle node and return it. Time Complexity: \\(O(n)\\) Code: class Solution: def get_length(self, head): \"\"\" Helper function- iterates over the entire linked list and returns the length of the list \"\"\" counter = 0 while head: counter += 1 head = head.next return counter def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]: # Handle the base case if not head: return # Compute the middle index n = self.get_length(head) mid = n // 2 # Iterate mid number of steps i = 0 while i < mid: head = head.next # note that we are updating the head. So after \"mid\" iterations, head = middle node i+=1 # Since head = mid after iterating, we return head return head 7. Delete the Middle Node 7.1 Using Iteration We\u2019ve already discussed how to find the middle node in a linked list, right? So, if we know how to reach the middle node, can we figure out how to delete it? \ud83e\udd14 To delete a node in a linked list, here\u2019s what we need to do: Stop at the node before the one we want to delete. Redirect the pointer: Change the next pointer of the current node to skip the node we want to delete and point to the node after it. Essentially, current.next = current.next.next . \u26a0\ufe0f Edge Cases: What if the linked list has only one node? In this scenario, we need to handle cases where current.next.next doesn\u2019t exist. Time Complexity: \\(O(n)\\) Code: class Solution: def get_length(self, head): \"\"\" Helper function- iterates over the entire linked list and returns the length of the list \"\"\" counter = 0 while head: counter += 1 head = head.next return counter def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]: mid = self.get_length(head) // 2 current = head # Iterate using current because we want to return the head i = 0 # Stopping one node before the middle node while i < mid - 1: current = current.next i += 1 # Change links of the node before to the next to next node by handling corner case if current.next and current.next.next: current.next = current.next.next else: current.next = None return head 8. Delete nth Node From End 8.1 Using Iteration This problem is very similar to the problem of deleting middle node. Observe that deleting the nth node from the end is the same as deleting (length - n)th node from the start. We can use a similar approach as we used in the above question to figure out the solution to this. 9. Merge Two Sorted Lists This problem is very similar to the merge(A, B) operation from the merge sort. But instead of merging arrays, we\u2019re merging linked lists! \ud83d\udd17 Code: class Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]: # Dummy node to serve as a proxy for head of the list to return dummy = ListNode() current = dummy # Iterate as long as neither list is exhausted while list1 and list2: if list1.val < list2.val: current.next = list1 list1 = list1.next else: current.next = list2 list2 = list2.next current = current.next # Attach the remaining nodes of list1 or list2 if list1: current.next = list1 elif list2: current.next = list2 # The merged list is next to the dummy node return dummy.next","title":"Leet Code Problems on Arrays, Lists, Stacks, Queues, and Hashing"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#leet-code-problems-on-arrays-lists-stacks-queues-and-hashing","text":"","title":"Leet Code Problems on Arrays, Lists, Stacks, Queues, and Hashing"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#table-of-contents","text":"","title":"\ud83d\udccb Table of Contents:"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#1-valid-parentheses","text":"","title":"1. Valid Parentheses"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#2-longest-consecutive-sequence","text":"","title":"2. Longest Consecutive Sequence"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#3-rotate-list","text":"","title":"3. Rotate List"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#4-swap-nodes-in-pairs","text":"","title":"4. Swap Nodes in Pairs"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#5-reverse-nodes-in-k-groups","text":"","title":"5. Reverse Nodes in K Groups"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#6-middle-of-the-linked-list","text":"","title":"6. Middle of The Linked List"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#7-delete-the-middle-node","text":"","title":"7. Delete the Middle Node"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#8-delete-nth-node-from-end","text":"","title":"8. Delete nth Node From End"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#9-merge-two-sorted-lists","text":"","title":"9. Merge Two Sorted Lists"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#1-valid-parentheses_1","text":"","title":"1. Valid Parentheses"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#11-using-stacks","text":"\ud83d\udd0d Problem Understanding: There are only three types of brackets: [], (), {} . We need to close the last opened bracket first. This implies a Last In, First Out (LIFO) system. Can you think of the appropriate data structure here? Since LIFO behavior is required, a stack is perfect for tracking the parentheses. As we encounter opening parentheses, we add them to the stack. When we see a closing bracket, we remove (pop) the last added one. \ud83e\udd14 Think about this: Imagine you've processed the first two characters of the string and added them to the stack. Your stack might look like this: stack = ['(', '{']. Now, suppose the next character is }. How do you check if this closing bracket matches the last opened one? We can maintain a mapping like this: \\ closing bracket : its corresponding opening bracket . This allows us to verify that each closing bracket properly matches its corresponding opening one. \u26a0\ufe0f Edge Cases: What if there are opening brackets left in the stack, but no more characters in the string? Or vice versa\u2014what if there are closing brackets in the string, but no opening ones left in the stack? Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\)","title":"1.1 Using Stacks"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#code-implementation","text":"class Solution: def isValid(self, s: str) -> bool: # Keep the mapping as 'closing bracket' : 'Correspoding opening bracket' mapping = { ')' : '(', ']' : '[', '}' : '{' } stack = [ ] # O(n) for char in s: if char not in mapping: # This means that the bracket is an open bracket stack.append(char) # Simply add the open bracket to the stack else: # Corner case- stack has no elements but the string has closing bracket if len(stack) == 0: return False # Check if opening bracket in the stack matches with the closing bracket in the string if mapping[char] != stack.pop(): return False # if stack is empty after checking every char of string # that means that we found the closing bracket for every opening bracket. Thus, return True # And vice versa. Return False return not stack # Returns True if stack is empty, False otherwise","title":"\ud83d\udcbb Code Implementation::"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#2-longest-consecutive-sequence_1","text":"","title":"2. Longest Consecutive Sequence"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#21-brute-force","text":"For every element, iterate over the array to check if the next element exists in the array. Keep doing this as long as the next element is found. Keep a counter for each sequence, and track the maximum. Time Complexity: \\(O(n^2)\\) . But we are told to find an \\(O(n)\\) solution!","title":"2.1 Brute Force"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#22-improved-approach-using-sets","text":"\ud83e\udde0 Deep Dive: In the brute-force approach, we had to iterate through the entire unsorted array to check if the next element existed. Is there a way to optimize this check? Hint : Consider using a data structure that allows constant-time lookups. We can use set data structure to serve this purpose! How would you solve this using sets? - For each number, while the next consecutive number exists, keep counting. - However, if we use this method directly, some numbers may be checked more than once, leading to \\(O(n^2)\\) time complexity. Can we do better? Which numbers can start a consecutive sequence? - Only those numbers n where n-1 is not in the set. Only these numbers can be the starting points of the longest consecutive sequence. Can you see why? - By finding these starting points, we can run our loop efficiently on only these elements. - Time Complexity: \\(O(n)\\) - Space Complexity: \\(O(n)\\)","title":"2.2 Improved Approach Using Sets"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#code","text":"class Solution: def longestConsecutive(self, nums: List[int]) -> int: # Convert nums to a set num_set = set(nums) starting_points = set() # Only those elements can be starting points where n - 1 is not in num_set # O(n) for num in nums: if num - 1 not in num_set: starting_points.add(num) max_length = 0 # Overall O(n), because the inner while loop is just going to run once for other elements for current_num in starting_points: current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length","title":"Code:"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#3-rotate-list_1","text":"","title":"3. Rotate List"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#31-rotation-logic","text":"If \\(k \\gt n\\) , then the number of effective rotations is: \\(k = k \\mod n\\) . Think about this as a three step problem: First, traverse \\(k\\) nodes. This n - k th node becomes the newhead of the rotated list. Next, connect the original list's tail to its head to create a cycle in the linked list. Finally, walk from the newhead for n nodes to find the newtail , which will become the tail of the rotated list by marking its next pointer as None.","title":"3.1 \ud83d\udd04 Rotation Logic:"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#code-implementation_1","text":"class Solution: # Gets the length of node: 'n' def get_length(self, head): current = head count = 0 while current: current = current.next count += 1 return count def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]: n = self.get_length(head) # Corner case if n <= 1: return head k = k % n # Number of effective rotations # In the original list, you need to walk these many steps to get to new head walk_these_many_steps = n - k if k == 0 or walk_these_many_steps == 0: return head # Get the new head of the list that you will get after you rotate current = head count = 0 newhead = None while current: if count == walk_these_many_steps: newhead = current break current = current.next count += 1 # Get to the end of the list so that you can link tail with the head. # But now your linked list is a cycle current = head count = 0 while current: if not current.next: current.next = head break current = current.next # Now you need to make the new tail point to None to break the cycle current = newhead count = 0 while current and count < n: current = current.next count += 1 if count == n - 1: current.next = None return newhead","title":"\ud83d\udcbb Code Implementation::"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#4-swap-nodes-in-pairs_1","text":"","title":"4. Swap Nodes in Pairs"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#5-reverse-nodes-in-k-groups_1","text":"","title":"5. Reverse Nodes in K Groups"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#51-using-recursion","text":"We know how to reverse a linked list from the Graded Assignment question. Given k, we can reverse the first k nodes and return the head and tail of the reversed portion. For the next k nodes, you can pass the kth_node.next as the head and reverse the subsequent k nodes, returning their head and tail. This way, you reverse groups of k nodes. But how do you connect these groups? \ud83e\udd14 Can you think of a recursive way? - Remember that the last reversed k nodes will be the first to return! - Let's take an example list: 1 -> 2 -> 3 -> 4 , and k = 2 . - First, reverse 1 -> 2 as 2 -> 1 , and return the head as 2 and tail as 1 . - Then, reverse 3 -> 4 recursively as 4 -> 3 , and return the head as 4 and tail as 3 . - Now, Now, you just need to connect the tail of the first reversed group (1) to the head of the second reversed group (4). Voil\u00e0! You've connected the reversed groups.","title":"5.1 Using Recursion"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#code_1","text":"class Solution: # Helper function: returns the number of nodes in the linked list def get_length(self, head): count = 0 current = head while current: current = current.next count += 1 return count def reverse(self, head, k, n): if not head: return head, None # If k > n, then remaining nodes should remain as they are if k > n: return head, None # Reverse the K nodes in groups current = head prev = None next_node = None count = 0 while current and count <= k: # Counting because we want to mark the tail also if count < k: next_node = current.next current.next = prev prev = current current = next_node count += 1 curr_head = prev # The head of the reversed k nodes curr_tail = head # tail of the reversed k nodes # Recursively call reverse on the next k nodes next_head, next_tail = self.reverse(next_node, k, n - k) # Connect the current group's tail with the head of the next group curr_tail.next = next_head return curr_head, curr_tail def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]: n = self.get_length(head) head, tail = self.reverse(head, k, n) return head","title":"Code:"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#6-middle-of-the-linked-list_1","text":"","title":"6. Middle of The Linked List"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#61-using-iteration","text":"How do we find the middle element in an array? We typically compute the middle index as: mid = len(L) // 2 and then return L[mid] . Can you find out a similar approach in linked lists? Let's explore this: First, iterate over the entire list to determine its length. Next, compute the middle index. Finally, traverse the list up to the middle node and return it. Time Complexity: \\(O(n)\\)","title":"6.1 Using Iteration"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#code_2","text":"class Solution: def get_length(self, head): \"\"\" Helper function- iterates over the entire linked list and returns the length of the list \"\"\" counter = 0 while head: counter += 1 head = head.next return counter def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]: # Handle the base case if not head: return # Compute the middle index n = self.get_length(head) mid = n // 2 # Iterate mid number of steps i = 0 while i < mid: head = head.next # note that we are updating the head. So after \"mid\" iterations, head = middle node i+=1 # Since head = mid after iterating, we return head return head","title":"Code:"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#7-delete-the-middle-node_1","text":"","title":"7. Delete the Middle Node"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#71-using-iteration","text":"We\u2019ve already discussed how to find the middle node in a linked list, right? So, if we know how to reach the middle node, can we figure out how to delete it? \ud83e\udd14 To delete a node in a linked list, here\u2019s what we need to do: Stop at the node before the one we want to delete. Redirect the pointer: Change the next pointer of the current node to skip the node we want to delete and point to the node after it. Essentially, current.next = current.next.next . \u26a0\ufe0f Edge Cases: What if the linked list has only one node? In this scenario, we need to handle cases where current.next.next doesn\u2019t exist. Time Complexity: \\(O(n)\\)","title":"7.1 Using Iteration"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#code_3","text":"class Solution: def get_length(self, head): \"\"\" Helper function- iterates over the entire linked list and returns the length of the list \"\"\" counter = 0 while head: counter += 1 head = head.next return counter def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]: mid = self.get_length(head) // 2 current = head # Iterate using current because we want to return the head i = 0 # Stopping one node before the middle node while i < mid - 1: current = current.next i += 1 # Change links of the node before to the next to next node by handling corner case if current.next and current.next.next: current.next = current.next.next else: current.next = None return head","title":"Code:"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#8-delete-nth-node-from-end_1","text":"","title":"8. Delete nth Node From End"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#81-using-iteration","text":"This problem is very similar to the problem of deleting middle node. Observe that deleting the nth node from the end is the same as deleting (length - n)th node from the start. We can use a similar approach as we used in the above question to figure out the solution to this.","title":"8.1 Using Iteration"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#9-merge-two-sorted-lists_1","text":"This problem is very similar to the merge(A, B) operation from the merge sort. But instead of merging arrays, we\u2019re merging linked lists! \ud83d\udd17","title":"9. Merge Two Sorted Lists"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#code_4","text":"class Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]: # Dummy node to serve as a proxy for head of the list to return dummy = ListNode() current = dummy # Iterate as long as neither list is exhausted while list1 and list2: if list1.val < list2.val: current.next = list1 list1 = list1.next else: current.next = list2 list2 = list2.next current = current.next # Attach the remaining nodes of list1 or list2 if list1: current.next = list1 elif list2: current.next = list2 # The merged list is next to the dummy node return dummy.next","title":"Code:"},{"location":"Dynamic%20Programming/Questions/","text":"Leet Code Problems Based on Dynamic Programming 1. Climbing Stairs 2. House Robber 3. Fibonacci Numbers 4. Triangle 5. Coin Change 1. Climbing Stairs 1.1 Using Dynamic Programming Can you find out the recursive approach to this problem? Try to think about the base cases and the the recursive relation. When you are on the n th step, there are zero ways to reach n th step. If you are on the n-1 th step, there is only one way to reach n th step. Lastly, if you are on the n-2 th step, there are two ways of reaching the n th step. Further, if you observe, the following relationship holds: $$ ways(k) = ways(k - 1) + ways(k - 2) $$ The number of ways to reach a stair \\(k\\) is the sum of the number of ways to reach the stairs \\(k-1\\) and \\(k-2\\) . Can you think of a solution that uses dynamic programming and solves this problem in linear time? Code: class Solution: def climbStairs(self, n: int) -> int: L = [0]*n # Initialize the dynamic programming array # Base Cases if n == 1: return 1 if n == 2: return 2 L[0] = 1 L[1] = 2 # ways[i] = ways[i - 1] + ways[i - 2] for i in range(2, n): L[i] = L[i - 1] + L[i - 2] # Last element corresponds to the nth stair. So return that value. return L[-1] 2. House Robber 2.1 Using Dynamic Programming We cannot break two adjacent houses. That is, nums[i] and nums[i+1] cannot be stolen together. So, for each house, we have to decide whether we should rob it or not. Now, let's think about how we can keep track of the maximum amount of money you can rob up to each house. We could use an array where each element represents the maximum amount of money that can be robbed up to that house. That is, maximum_amount[i] tells us the maximum amount of money that could be stolen up to the house i . What might be the base cases for this maximum_amount , abbreviated as m_a , array? - When it's the first house, then m_a[0] should the amount in the first house. - When it's the second house, then m_a[1] should be the maximum for nums[0] and nums[1] , since they are adjacent and we cannot rob both. Can you come up with a recursive relation that solves this problem? - From the third house onwards, we can either rob the house or choose to not rob it. If we rob it, we can't rob the previous house. If we don't rob it, we can rob the previous house. - In our m_a array, we can represent the relation as this: - $ m_a[i] = max(m_a[i-1], m_a[i-2] + nums[i])$. - If we don't rob the current house, we are taking the amount stolen up to the previous house. - If we rob the current house, then we are taking the amount stolen up to the second previous house and adding the amount from the current house to it. Whatever value we have accumulated till the last house will be the maximum amount that we can steal. Time Complexity: \\(O(n)\\) Code: class Solution: def rob(self, nums: List[int]) -> int: if len(nums) == 1: return nums[0] maximum_amount = [0] * len(nums) # Base cases maximum_amount[0] = nums[0] maximum_amount[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): maximum_amount[i] = max(maximum_amount[i-1], maximum_amount[i-2] + nums[i]) return maximum_amount[-1] 3. Fibonacci Numbers 3.1 Using Dynamic Programming Let's begin by thinking about the problem. We need to calculate the Fibonacci number $F(n) $ for a given \\(n\\) . The Fibonacci sequence is defined as: $ F(0) = 0$ \\(F(1) = 1\\) \\(F(n) = F(n-1) + F(n-2) \\text{ for } n > 1\\) Consider what this means. \\(F(n)\\) is the sum of the two preceding numbers in the sequence. This suggests that if we know \\(F(n-1)\\) and \\(F(n-2)\\) , we can find $F(n) $. But how do we approach calculating \\(F(n)\\) ? First, think about the simplest cases, \\(F(0)\\) and \\(F(1)\\) . These are our base cases because they are defined directly without requiring any further calculations. Now, if \\(n = 2\\) , we use the formula \\(F(2) = F(1) + F(0)\\) . Since we already know $F(1) = 1 $ and $ F(0) = 0$, we can easily calculate $F(2) = 1 + 0 = 1 $. What if \\(n = 3\\) ? Again, using the formula, $F(3) = F(2) + F(1) $. From the previous steps, we know $ F(2) = 1 $ and $F(1) = 1 $, so $F(3) = 1 + 1 = 2 $. Notice that each time we calculate a Fibonacci number, we rely on the results of previous calculations. Now, let\u2019s consider a general approach. If we want to calculate $F(n) $, how can we systematically work our way up from the base cases to $F(n) $? One way is to use recursion . We can define a function that calls itself with smaller values of $ n $ until it reaches the base cases. However, while recursion is elegant, it has a downside\u2014repeatedly solving the same subproblems, which leads to inefficiency. Can we improve this? Yes, we can! Instead of recalculating the same Fibonacci numbers multiple times, we can store the results of each calculation and reuse them when needed. So here's the approach that we will take: - We will define an array named fibtable , where fibtable[i] is the ith number in the fibonacci sequence. - Observe this relationship: fibtable[i] = fibtable[i - 1] + fibtable[i - 2] - Once we hardcode the base cases, we can iterate over the i upto n , and update the fibtable[i] as per the above update condition. Code: class Solution: def fib(self, n: int) -> int: # Initialize the fibtable array to be all zeros fibtable = [0] * (n + 1) # Base Case 1: Where n == 0 if n == 0: return fibtable[0] # Base Case 2: Where n == 1 fibtable[1] = 1 for i in range(2, n + 1): #F(n) = F(n - 1) + F(n - 2) fibtable[i] = fibtable[i - 1] + fibtable[i - 2] # fibtable[i] is the ith fibonacci number. Thus, to get nth fibonacci number, return fibtable[n] return fibtable[n] 4. Triangle 4.1 Using Dynamic Programming The question is asking for us to find the minimum path sum from the top to the bottom of the triangle, where each step can be to only the ith or i + 1 th cell in the row below. Can you break this problem into further subproblems? - If we start from the topmost cell of the triangle in the test case 1, the minimum path sum could be described using the following structure: \\(MPS(2) = 2 + min(MPS(3), MPS(4))\\) , where $MPS(x) $ tells us the minimum path sum starting from a particular cell in the triangle. More generally, \\(MPS(triangle[row][col]) = triangle[row][col]+ min(MPS(triangle[row + 1][col]), MPS(triangle[row + 1][col + 1]))\\) Can you identify the base cases here? - The base cases are all the leaf nodes of the triangle where there are no more children. Since we are solving subproblems and then combining those subproblems to solve the original problem, we can use dynamic programming here. Further, using bottom-up approach here might be better than using the top-down approach. After processing the last row, that is- the row of the base cases, we can move one level up in the triangle. After processing that level, we get a minimum path of length 2 for each of the cells in the second last row. More generally, after processing a row, each element in that row would hold the minimum path sum from that element to the bottom of the triangle. After processing the entire triangle, the top element of the triangle would hold the minimum path sum from the top to the bottom of the triangle, which is the answer to the problem. Here's how we can approach the pseudocode: - Start with the second last row. ( We don't need to start from the last row, as the last row is the base case and it will return values just the same as what are there in the cells) - Then for every cell of that row, we apply the following update rule: \\( \\(MPS(triangle[row][col]) = triangle[row][col]+ min(MPS(triangle[row + 1][col]), MPS(triangle[row + 1][col + 1]))\\) \\) - Repeat the same for every row till you reach the topmost row. - Return the value from the cell at the top- first cell of the first row. class Solution: def minimumTotal(self, triangle: List[List[int]]) -> int: # Start from the second-to-last row of the triangle for row in range(len(triangle) - 2, -1, -1): for col in range(len(triangle[row])): # Update the current element with the sum of the element itself # and the minimum of the two adjacent elements in the row below triangle[row][col] = triangle[row][col] + min(triangle[row + 1][col], triangle[row + 1][col + 1]) # The top element now contains the minimum path sum return triangle[0][0] 5. Coin Change 5.1 Using Dynamic Programming The first thought here can be that we need to use the greedy strategy. But as we can see from the test cases, the greedy strategy won't always give us the optimal solution. Can you try to break this problem down into subproblems and identify if there are overlapping subproblems? - We can observe that for a given amount, the minimum number of coins needed to get to that amount is one plus the minimum number of coins required to get \\(amount - coin\\) . Concisely, we can write this as: - \\(mincoins(amount) = mincoins(amount - coin) + 1\\) - If you expand the subproblems for every coin in the given test case, you can observe that the subproblems overlap. How can you use dynamic programming to solve this problem? - Since we know the subproblem structure, we can use memoization. - Keep an array of length \\(amount + 1\\) , where each index i stores the minimum number of coins required to get change for amount i . Let this array be called dp . - Initially this array will be set to infinity. - For each element, we will update the value as: - dp[i] = min(dp[i], dp[i - coin] + 1) - We will do this for every amount in range(0, amount + 1) , and we will do this for every coin in the coins array. What can be the base cases here? - To get to amount \\(0\\) , we need \\(0\\) coins. Thus, dp[0] = 0 . - Further, for every coin in the given coins array, dp[coin] = 1 , as one coin will suffice to get to that amount. Code: class Solution: def coinChange(self, coins, amount): # Initialize a dp array where dp[i] will hold the minimum number of coins required for amount i dp = [float('inf')] * (amount + 1) # Base case: No coins are needed to make amount 0 dp[0] = 0 for coin in coins: dp[coin] = 1 # Fill the dp array for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) # If dp[amount] is still inf, it means it's not possible to make that amount with given coins return dp[amount] if dp[amount] != float('inf') else -1","title":"Leet Code Problems Based on Dynamic Programming"},{"location":"Dynamic%20Programming/Questions/#leet-code-problems-based-on-dynamic-programming","text":"","title":"Leet Code Problems Based on Dynamic Programming"},{"location":"Dynamic%20Programming/Questions/#1-climbing-stairs","text":"","title":"1. Climbing Stairs"},{"location":"Dynamic%20Programming/Questions/#2-house-robber","text":"","title":"2. House Robber"},{"location":"Dynamic%20Programming/Questions/#3-fibonacci-numbers","text":"","title":"3. Fibonacci Numbers"},{"location":"Dynamic%20Programming/Questions/#4-triangle","text":"","title":"4. Triangle"},{"location":"Dynamic%20Programming/Questions/#5-coin-change","text":"","title":"5. Coin Change"},{"location":"Dynamic%20Programming/Questions/#1-climbing-stairs_1","text":"","title":"1. Climbing Stairs"},{"location":"Dynamic%20Programming/Questions/#11-using-dynamic-programming","text":"Can you find out the recursive approach to this problem? Try to think about the base cases and the the recursive relation. When you are on the n th step, there are zero ways to reach n th step. If you are on the n-1 th step, there is only one way to reach n th step. Lastly, if you are on the n-2 th step, there are two ways of reaching the n th step. Further, if you observe, the following relationship holds: $$ ways(k) = ways(k - 1) + ways(k - 2) $$ The number of ways to reach a stair \\(k\\) is the sum of the number of ways to reach the stairs \\(k-1\\) and \\(k-2\\) . Can you think of a solution that uses dynamic programming and solves this problem in linear time?","title":"1.1 Using Dynamic Programming"},{"location":"Dynamic%20Programming/Questions/#code","text":"class Solution: def climbStairs(self, n: int) -> int: L = [0]*n # Initialize the dynamic programming array # Base Cases if n == 1: return 1 if n == 2: return 2 L[0] = 1 L[1] = 2 # ways[i] = ways[i - 1] + ways[i - 2] for i in range(2, n): L[i] = L[i - 1] + L[i - 2] # Last element corresponds to the nth stair. So return that value. return L[-1]","title":"Code:"},{"location":"Dynamic%20Programming/Questions/#2-house-robber_1","text":"","title":"2. House Robber"},{"location":"Dynamic%20Programming/Questions/#21-using-dynamic-programming","text":"We cannot break two adjacent houses. That is, nums[i] and nums[i+1] cannot be stolen together. So, for each house, we have to decide whether we should rob it or not. Now, let's think about how we can keep track of the maximum amount of money you can rob up to each house. We could use an array where each element represents the maximum amount of money that can be robbed up to that house. That is, maximum_amount[i] tells us the maximum amount of money that could be stolen up to the house i . What might be the base cases for this maximum_amount , abbreviated as m_a , array? - When it's the first house, then m_a[0] should the amount in the first house. - When it's the second house, then m_a[1] should be the maximum for nums[0] and nums[1] , since they are adjacent and we cannot rob both. Can you come up with a recursive relation that solves this problem? - From the third house onwards, we can either rob the house or choose to not rob it. If we rob it, we can't rob the previous house. If we don't rob it, we can rob the previous house. - In our m_a array, we can represent the relation as this: - $ m_a[i] = max(m_a[i-1], m_a[i-2] + nums[i])$. - If we don't rob the current house, we are taking the amount stolen up to the previous house. - If we rob the current house, then we are taking the amount stolen up to the second previous house and adding the amount from the current house to it. Whatever value we have accumulated till the last house will be the maximum amount that we can steal. Time Complexity: \\(O(n)\\)","title":"2.1 Using Dynamic Programming"},{"location":"Dynamic%20Programming/Questions/#code_1","text":"class Solution: def rob(self, nums: List[int]) -> int: if len(nums) == 1: return nums[0] maximum_amount = [0] * len(nums) # Base cases maximum_amount[0] = nums[0] maximum_amount[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): maximum_amount[i] = max(maximum_amount[i-1], maximum_amount[i-2] + nums[i]) return maximum_amount[-1]","title":"Code:"},{"location":"Dynamic%20Programming/Questions/#3-fibonacci-numbers_1","text":"","title":"3. Fibonacci Numbers"},{"location":"Dynamic%20Programming/Questions/#31-using-dynamic-programming","text":"Let's begin by thinking about the problem. We need to calculate the Fibonacci number $F(n) $ for a given \\(n\\) . The Fibonacci sequence is defined as: $ F(0) = 0$ \\(F(1) = 1\\) \\(F(n) = F(n-1) + F(n-2) \\text{ for } n > 1\\) Consider what this means. \\(F(n)\\) is the sum of the two preceding numbers in the sequence. This suggests that if we know \\(F(n-1)\\) and \\(F(n-2)\\) , we can find $F(n) $. But how do we approach calculating \\(F(n)\\) ? First, think about the simplest cases, \\(F(0)\\) and \\(F(1)\\) . These are our base cases because they are defined directly without requiring any further calculations. Now, if \\(n = 2\\) , we use the formula \\(F(2) = F(1) + F(0)\\) . Since we already know $F(1) = 1 $ and $ F(0) = 0$, we can easily calculate $F(2) = 1 + 0 = 1 $. What if \\(n = 3\\) ? Again, using the formula, $F(3) = F(2) + F(1) $. From the previous steps, we know $ F(2) = 1 $ and $F(1) = 1 $, so $F(3) = 1 + 1 = 2 $. Notice that each time we calculate a Fibonacci number, we rely on the results of previous calculations. Now, let\u2019s consider a general approach. If we want to calculate $F(n) $, how can we systematically work our way up from the base cases to $F(n) $? One way is to use recursion . We can define a function that calls itself with smaller values of $ n $ until it reaches the base cases. However, while recursion is elegant, it has a downside\u2014repeatedly solving the same subproblems, which leads to inefficiency. Can we improve this? Yes, we can! Instead of recalculating the same Fibonacci numbers multiple times, we can store the results of each calculation and reuse them when needed. So here's the approach that we will take: - We will define an array named fibtable , where fibtable[i] is the ith number in the fibonacci sequence. - Observe this relationship: fibtable[i] = fibtable[i - 1] + fibtable[i - 2] - Once we hardcode the base cases, we can iterate over the i upto n , and update the fibtable[i] as per the above update condition.","title":"3.1 Using Dynamic Programming"},{"location":"Dynamic%20Programming/Questions/#code_2","text":"class Solution: def fib(self, n: int) -> int: # Initialize the fibtable array to be all zeros fibtable = [0] * (n + 1) # Base Case 1: Where n == 0 if n == 0: return fibtable[0] # Base Case 2: Where n == 1 fibtable[1] = 1 for i in range(2, n + 1): #F(n) = F(n - 1) + F(n - 2) fibtable[i] = fibtable[i - 1] + fibtable[i - 2] # fibtable[i] is the ith fibonacci number. Thus, to get nth fibonacci number, return fibtable[n] return fibtable[n]","title":"Code:"},{"location":"Dynamic%20Programming/Questions/#4-triangle_1","text":"","title":"4. Triangle"},{"location":"Dynamic%20Programming/Questions/#41-using-dynamic-programming","text":"The question is asking for us to find the minimum path sum from the top to the bottom of the triangle, where each step can be to only the ith or i + 1 th cell in the row below. Can you break this problem into further subproblems? - If we start from the topmost cell of the triangle in the test case 1, the minimum path sum could be described using the following structure: \\(MPS(2) = 2 + min(MPS(3), MPS(4))\\) , where $MPS(x) $ tells us the minimum path sum starting from a particular cell in the triangle. More generally, \\(MPS(triangle[row][col]) = triangle[row][col]+ min(MPS(triangle[row + 1][col]), MPS(triangle[row + 1][col + 1]))\\) Can you identify the base cases here? - The base cases are all the leaf nodes of the triangle where there are no more children. Since we are solving subproblems and then combining those subproblems to solve the original problem, we can use dynamic programming here. Further, using bottom-up approach here might be better than using the top-down approach. After processing the last row, that is- the row of the base cases, we can move one level up in the triangle. After processing that level, we get a minimum path of length 2 for each of the cells in the second last row. More generally, after processing a row, each element in that row would hold the minimum path sum from that element to the bottom of the triangle. After processing the entire triangle, the top element of the triangle would hold the minimum path sum from the top to the bottom of the triangle, which is the answer to the problem. Here's how we can approach the pseudocode: - Start with the second last row. ( We don't need to start from the last row, as the last row is the base case and it will return values just the same as what are there in the cells) - Then for every cell of that row, we apply the following update rule: \\( \\(MPS(triangle[row][col]) = triangle[row][col]+ min(MPS(triangle[row + 1][col]), MPS(triangle[row + 1][col + 1]))\\) \\) - Repeat the same for every row till you reach the topmost row. - Return the value from the cell at the top- first cell of the first row. class Solution: def minimumTotal(self, triangle: List[List[int]]) -> int: # Start from the second-to-last row of the triangle for row in range(len(triangle) - 2, -1, -1): for col in range(len(triangle[row])): # Update the current element with the sum of the element itself # and the minimum of the two adjacent elements in the row below triangle[row][col] = triangle[row][col] + min(triangle[row + 1][col], triangle[row + 1][col + 1]) # The top element now contains the minimum path sum return triangle[0][0]","title":"4.1 Using Dynamic Programming"},{"location":"Dynamic%20Programming/Questions/#5-coin-change_1","text":"","title":"5. Coin Change"},{"location":"Dynamic%20Programming/Questions/#51-using-dynamic-programming","text":"The first thought here can be that we need to use the greedy strategy. But as we can see from the test cases, the greedy strategy won't always give us the optimal solution. Can you try to break this problem down into subproblems and identify if there are overlapping subproblems? - We can observe that for a given amount, the minimum number of coins needed to get to that amount is one plus the minimum number of coins required to get \\(amount - coin\\) . Concisely, we can write this as: - \\(mincoins(amount) = mincoins(amount - coin) + 1\\) - If you expand the subproblems for every coin in the given test case, you can observe that the subproblems overlap. How can you use dynamic programming to solve this problem? - Since we know the subproblem structure, we can use memoization. - Keep an array of length \\(amount + 1\\) , where each index i stores the minimum number of coins required to get change for amount i . Let this array be called dp . - Initially this array will be set to infinity. - For each element, we will update the value as: - dp[i] = min(dp[i], dp[i - coin] + 1) - We will do this for every amount in range(0, amount + 1) , and we will do this for every coin in the coins array. What can be the base cases here? - To get to amount \\(0\\) , we need \\(0\\) coins. Thus, dp[0] = 0 . - Further, for every coin in the given coins array, dp[coin] = 1 , as one coin will suffice to get to that amount.","title":"5.1 Using Dynamic Programming"},{"location":"Dynamic%20Programming/Questions/#code_3","text":"class Solution: def coinChange(self, coins, amount): # Initialize a dp array where dp[i] will hold the minimum number of coins required for amount i dp = [float('inf')] * (amount + 1) # Base case: No coins are needed to make amount 0 dp[0] = 0 for coin in coins: dp[coin] = 1 # Fill the dp array for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) # If dp[amount] is still inf, it means it's not possible to make that amount with given coins return dp[amount] if dp[amount] != float('inf') else -1","title":"Code:"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/","text":"Leet Code Problems on Graph Algorithms 1. Find the Town Judge 2. Course Schedule-I 3. Course Schedule-II 4. Snakes and Ladders 5. Sort Items By Groups Respecting Dependencies 6. Find If Path Exists 7. Number of Provinces 1. Find the Town Judge 1.1 By Counting Indegrees We're given the array trusts , where trust[i] = [a_i, b_i] means that a_i_ trusts b_i_ . Can we convert this problem into a graph problem? If a_i_ trusts b_i_ , then we can consider it an edge from a_i_ to b_i_ . The townjudge is a person who: - Trusts no one \\(\\implies outdegree(townjudge) = 0\\) , and - Everyone except him / herself trusts him / her \\(\\implies indegree(townjudge) = n - 1\\) . Keep two dictionaries: - To count the indegrees of all the nodes - To count the outdegrees of all the nodes Then for every person, check if its outdegree is \\(0\\) and indegree is \\(n-1\\) . Complexity: \\(O(n)\\) , since the creating the dictionaries takes \\(O(n)\\) and then iterating over people takes another \\(O(n)\\) . Code: class Solution: def findJudge(self, n: int, trust: List[List[int]]) -> int: if n <= 1: return 1 indegrees = { } outdegrees = { } # trust = [a_i, b_i] # a_i -> b_i for a, b in trust: if a not in indegrees: indegrees[a] = 0 if b not in indegrees: indegrees[b] = 0 if a not in outdegrees: outdegrees[a] = 0 if b not in outdegrees: outdegrees[b] = 0 outdegrees[a] += 1 indegrees[b] += 1 # If indegree == n - 1 and outdegree == 0, then we have found the town judge. townjudge = -1 for person in indegrees: if outdegrees[person] == 0: if indegrees[person] >= n - 1: townjudge = person break return townjudge 2. Course Schedule-I 2.1 Topological Sorting The prerequisites[i] = [a_i, b_i] \\(\\implies\\) b_i has to come before a_i . In other words, a_i is dependent on b_i . Can you convert this problem into a graph problem? Further, which algorithm do we need to use to find a sequence that satisfies dependencies? If b_i has to come before a_i , then we add an edge from b_i to a_i . Please note the direction of the edge. We can convert this into an adjacency matrix or an adjacency list. For this problem, we are converting the graph into an adjacency matrix. Once we have converted this problem into a graph problem, we can use the algorithm we use when we need to find a sequence that satisfies some dependencies- topological sorting. When would you say that we have successfully found the sequence of courses satisfying the dependencies? When we the sequence that we get has all the courses- no course is left. Code: class Solution: def preprocessing(self, numCourses, prerequisites) -> list[list[int]]: adjacency_matrix = [ [0 for i in range(numCourses)] for i in range(numCourses) ] for a, b in prerequisites: adjacency_matrix[b][a] = 1 return adjacency_matrix # Implementation of Topological sort for Adjacency matrix def toposort(self, AMat): #Initialization (rows,cols) = len(AMat), len(AMat[0]) indegree = {} toposortlist = [] #Compute indegree for each vertex for c in range(cols): indegree[c] = 0 for r in range(rows): if AMat[r][c] == 1: indegree[c] = indegree[c] + 1 # Topological sort Computing process for i in range(rows): # Select the min level vertex for removing the graph which has indegree 0 zero_indegree = [k for k in range(cols) if indegree[k] == 0] if not zero_indegree:return toposortlist #Handle the case where there are no more zero indegree vertices j = zero_indegree[0] # Store the removed vertex j in toposortlist and reduce the indegree by one toposortlist.append(j) indegree[j] = indegree[j] - 1 # Reduce the indegree of each adjacent of the removed vertex j by 1 for k in range(cols): if AMat[j][k] == 1: indegree[k] = indegree[k] - 1 return(toposortlist) def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool: adjacency_matrix = self.preprocessing(numCourses, prerequisites) toposortlist = self.toposort(adjacency_matrix) if len(toposortlist) == numCourses: return True return False 2.2 Topological Sort: Better Implementation The approach used is similar to the above approach. However, we are utilizing better data structures to increase our performance. Instead of keeping an adjacency matrix, we are utilizing a combination of doubly ended queues and adjacency lists. Here's how: - Keep a deque for vertices with zero degree queue such that the insert at end and delete from start operations are both constant time. - Keep a dictionary of indegrees which counts the indegrees for each vertex Complexity: $O(|V| + |E|) Code: from collections import deque, Counter class Solution: def canFinish(self, numCourse, prerequisites): AList = { i: [] for i in range(numCourse)} indegree = Counter() visited = { i:False for i in range(numCourse)} for course, prereq in prerequisites: AList[prereq].append(course) indegree[course] += 1 # Initialization toposortlist = [] zerodegreeq = deque() # Find the vertex with indegree 0 and added into the queue for u in range(numCourse): if indegree[u] == 0: zerodegreeq.append(u) # Topological sort Computing process while (zerodegreeq): # Remove one vertex from queue which have zero degree vertices curr_vertex = zerodegreeq.popleft() # Store the removed vertex in toposortlist and reduce the indegree by one toposortlist.append(curr_vertex) indegree[curr_vertex] = indegree[curr_vertex]-1 # Repeat for each adjacent of the removed vertex for adj_vertex in AList[curr_vertex]: # Reduce the indegree of each adjacent of the removed vertex by 1 indegree[adj_vertex] = indegree[adj_vertex] - 1 # If after reducing the degree of adjacent, it becomes zero then insert it into the queue if indegree[adj_vertex] == 0: zerodegreeq.append(adj_vertex) return len(toposortlist) == numCourse 3. Course Schedule-II This problem is an exact replica of the above problem, except that we have to return a sequence that satisfies the dependencies, instead of returning a boolean of whether or not we can create such a sequence. We can use the same approaches discussed in the above question. 4. Snakes and Ladders 4.1 Using BFS We are given a board with \\(n^2\\) cells. From any particular cell, there can be at maximum only six moves. Can we convert this structure into a graph? For example, in the first test case, assume we are at cell \\(1\\) . The next possible moves are: \\(15, 3, 4, 5, 6, 7\\) because \\(2\\) has a ladder to \\(15\\) . From cell \\(1\\) , we can make each of the next possible moves as an edge. The task is to find the least number of moves required to reach \\(n^2\\) starting from \\(1\\) . Can you identify what type of a problem this is and which algorithm we can use for this problem? It's a shortest path problem without edge weights. The algorithm that we can use for this problem is BFS. Pseudocode: - We first need to convert the board into a graph. - For every cell, check the next six cells. - If the cell has a ladder or a snake, then we need to find out where the ladder ends which is given in cell: board[row][col] - If the cell does not have a ladder or a snake, then board[row][col] will have the vaue \\(-1\\) . - Add the edge as: [cell] to board[row][cell] or the next moves. Once we have the graph, we can run BFS on this graph, which will return the shortest path. Code: 5. Sort Items By Groups Respecting Dependencies 5.1 Using Topological Sort We need to list a a sequential order of items such that the items belonging to the same group are listed next to each other. Each item can have a dependency such that the other item needs to be completed first- as given in the beforeItems array. It is easy to see that this is a topological ordering problem. Take a moment to think about the following: Let's say we run topological sort directly on the beforeItems. We may pass some test cases. But what test cases might we fail? Whenever we have multiple items that have zero indegree, then we have to make a choice as to which item should we take first. Let's take an example: group[0] = [1, 2] group[1] = [3, 4] indegree[1] = 0 indegree[3] = 0 indegree[2] = indegree[4] = 1 Assume: 2 needs to be come before 4, and 1 needs to come before 2. 1 -> 2 -> 4 Now, the issue will come when we are selecting between the items 1 and 3. If our algorithm chooses 3, then all the other elements belonging to group 1 should come next to 3- like: 3, 4-, and only then we'll be able to add elements from group 0- like: 3, 4, 1, 2. This violates the condition that 1 -> 2 -> 4 . To solve this problem, we need to keep a graph for the groups as well. Whenever we are choosing which item to select for the topological order, we need to first check the groups graph. Thus, we keep two graphs- one for items and one for groups . Then we run a sort of nested topological sort- the outer one for the groups graph, and the inner one for the items graph. This will give us the correct solution that respects both the group dependencies and the item dependencies. Psuedocode: Since we are going to need to list all elements belonging to a group side by side, we will keep a dictionary of the format: group:[all items of that group] for easy retrieval. Use beforeItems array to construct both the graphs- groups and items . You can use the either an adjacency matrix or an adjacency list representation for this. Here, we are using Adjacency List representation. If items[i] needs to come before items[j] , then add edge from i to j for the items_graph . Similarly, for the group_graph , add the edge from group[i] to group[j] , since the item in i th group needs to come before the item in the j th group. Once you have the graphs, run nested topological sort as mentioned above. Code: # Implementation of Queue class Queue: def __init__(self): self.queue = [] def enqueue(self,v): self.queue.append(v) def isempty(self): return(self.queue == []) def dequeue(self): v = None if not self.isempty(): v = self.queue[0] self.queue = self.queue[1:] return(v) def __str__(self): return(str(self.queue)) class Solution: # Creates a dictionary that returns all elements of a particular group. Used in the main algorithm when we are listing all the items # that belong to a group side by side def get_group_wise_elements(self, group, m): group_wise_elements = { i:[] for i in range(m) } for i in range(len(group)): grp = group[i] if group[i] >= 0 else -i-1 if grp not in group_wise_elements: group_wise_elements[grp] = [] group_wise_elements[grp].append(i) return group_wise_elements # Convert the problem into two graphs- group_graph and items_graph. Along with it, return indegrees for each node in both the graphs. def preprocessing(self, beforeItems, group, m, n, groupwise_items): group_indegree, items_indegree = {}, {i:0 for i in range(n)} items_alist = {i:[] for i in range(n)} group_alist = {} for key in groupwise_items: group_alist[key] = set() group_indegree[key] = 0 for i in range(len(beforeItems)): before = beforeItems[i] for num in before: if num not in items_alist: items_alist[num] = [ ] items_alist[num].append(i) items_indegree[i] += 1 grp_num = group[num] if group[num] >= 0 else -num-1 grp_i = group[i] if group[i] >= 0 else -i-1 if grp_num != grp_i: if grp_num not in group_alist: group_alist[grp_num] = set() group_alist[grp_num].add(grp_i) for key in group_alist.keys(): group_alist[key] = list(group_alist[key]) for u in group_alist.keys(): for v in group_alist[u]: if v not in group_indegree: group_indegree[v] = 0 group_indegree[v] += 1 return items_alist, group_alist, items_indegree, group_indegree # Run the actual nested topological sorting algorithm def lpath(self, items_alist, group_alist, items_indegree, group_indegree, groupwise_items, n, group): output = [ ] grp_queue = Queue() items_queue = Queue() for grp in group_indegree: if group_indegree[grp] == 0: grp_queue.enqueue(grp) # Outer topological sort is for groups while not grp_queue.isempty(): curr_grp = grp_queue.dequeue() group_indegree[curr_grp] -= 1 for adj_grp in group_alist[curr_grp]: # Reduce the indegree of each adjacent group of the removed vertex by 1 group_indegree[adj_grp] -= 1 # If after reducing the degree of adjacent group, it becomes zero then insert it into the group queue if group_indegree[adj_grp] == 0 : grp_queue.enqueue(adj_grp) for i in groupwise_items[curr_grp]: if items_indegree[i] == 0 : items_queue.enqueue(i) # Inner topological sort is for the items while (not items_queue.isempty()): # Remove one vertex from items queue which have zero degree items and reduce the indegree by 1 curr_vertex = items_queue.dequeue() output.append(curr_vertex) items_indegree[curr_vertex] = items_indegree[curr_vertex] - 1 # Repeat for each adjacent of the removed item for adj_vertex in items_alist[curr_vertex]: # Reduce the indegree of each adjacent of the removed item by 1 items_indegree[adj_vertex] = items_indegree[adj_vertex] - 1 # If after reducing the degree of adjacent item, it becomes zero then insert it into the items queue if items_indegree[adj_vertex] == 0 and group[adj_vertex] == curr_grp: items_queue.enqueue(adj_vertex) if len(output) != n: return [] return output def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]: group_wise_items = self.get_group_wise_elements(group, m) items_alist, group_alist, items_indegree, group_indegree = self.preprocessing(beforeItems,group, m, n, group_wise_items) return self.lpath(items_alist, group_alist, items_indegree, group_indegree, group_wise_items, n, group) 6. Find If Path Exists 6.1 Using BFS What is the question asking you to do? - We need to find out whether we can reach a particular destination from the given source node. That is, it's a reachability problem. Can you convert the given edges list into an adjacency list or an adjacency matrix representation? - Each edges[i] = [u_i, v_i] represents a bidirectional edge, which means there is an edge from u to v , and v to u . - So we can iterate over the entire edges array, and add the two edges for every edges[i] . Here's the code snippet for converting the edges array into an adjacency list: for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) Once we have the adjacency list, which algorithm will give us whether we can reach destination from the source ? - We can use either BFS or DFS. For this solution, we are using BFS. Code: Note: For a better, more concise code, we have used the deque data structure from the collections module in Python. We can use it to implement a queue used in BFS. from collections import deque class Solution: def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool: adj_list = { i:[ ] for i in range(n) } visited = set() for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) queue = deque([source]) visited.add(source) while queue: vertex = queue.popleft() if vertex == destination: return True for neighbor in adj_list[vertex]: if neighbor not in visited: queue.append(neighbor) visited.add(neighbor) return False 7. Number of Provinces 7.1 Using BFS We are given a matrix isConnected , whose [i][j] th entry tells us whether there is an undirected edge from i to j . We can interpret this isConnected matrix as an adjacency matrix. A province is a set of vertices that are connected to each other. We are asked to find the number of provinces from the matrix. Can you identify the type of the problem? - The problem is about finding the number of connected components from the graph. Can you identify which algorithm we can use to solve this problem? - We can use BFS or DFS to solve this problem. For this solution, we will use BFS. Code: from collections import deque class Solution: def get_neighbors(self, AMat, vertex): \"\"\"Given an adjacency matrix and a vertex, returns all neighbors for that vertex\"\"\" neighbors = [] for i in range(len(AMat)): if AMat[vertex][i] == 1: neighbors.append(i) return neighbors def BFS(self, AMat, source): \"\"\" Runs BFS from a given source vertex and returns the set of vertices visited in that run of BFS. That is, each run of the BFS will give us one province, or one connected component. \"\"\" visited = set() queue = deque([source]) # Initialize the queue with the source vertex visited.add(source) while queue: vertex = queue.popleft() neighbors = self.get_neighbors(AMat, vertex) # Pass both AMat and vertex for neighbor in neighbors: if neighbor not in visited: queue.append(neighbor) visited.add(neighbor) return visited def findCircleNum(self, isConnected): # Initially, every vertex gets an invalid component number components = {i: -1 for i in range(len(isConnected))} # Keep track of the component number and the number of vertices already visited across BFS runs component_number = 0 seen = 0 while seen < len(isConnected): startv = min([i for i in range(len(isConnected)) if components[i] == -1]) visited = self.BFS(isConnected, startv) # For every vertex that was visited in the current run of BFS, update its component number and update # the number of vertices seen. for v in visited: components[v] = component_number seen += 1 # Increment component number such that for the next run of BFS, # a different component number will be assigned component_number += 1 return component_number","title":"Leet Code Problems on Graph Algorithms"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#leet-code-problems-on-graph-algorithms","text":"","title":"Leet Code Problems on Graph Algorithms"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#1-find-the-town-judge","text":"","title":"1. Find the Town Judge"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#2-course-schedule-i","text":"","title":"2. Course Schedule-I"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#3-course-schedule-ii","text":"","title":"3. Course Schedule-II"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#4-snakes-and-ladders","text":"","title":"4. Snakes and Ladders"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#5-sort-items-by-groups-respecting-dependencies","text":"","title":"5. Sort Items By Groups Respecting Dependencies"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#6-find-if-path-exists","text":"","title":"6. Find If Path Exists"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#7-number-of-provinces","text":"","title":"7. Number of Provinces"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#1-find-the-town-judge_1","text":"","title":"1. Find the Town Judge"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#11-by-counting-indegrees","text":"We're given the array trusts , where trust[i] = [a_i, b_i] means that a_i_ trusts b_i_ . Can we convert this problem into a graph problem? If a_i_ trusts b_i_ , then we can consider it an edge from a_i_ to b_i_ . The townjudge is a person who: - Trusts no one \\(\\implies outdegree(townjudge) = 0\\) , and - Everyone except him / herself trusts him / her \\(\\implies indegree(townjudge) = n - 1\\) . Keep two dictionaries: - To count the indegrees of all the nodes - To count the outdegrees of all the nodes Then for every person, check if its outdegree is \\(0\\) and indegree is \\(n-1\\) . Complexity: \\(O(n)\\) , since the creating the dictionaries takes \\(O(n)\\) and then iterating over people takes another \\(O(n)\\) .","title":"1.1 By Counting Indegrees"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#code","text":"class Solution: def findJudge(self, n: int, trust: List[List[int]]) -> int: if n <= 1: return 1 indegrees = { } outdegrees = { } # trust = [a_i, b_i] # a_i -> b_i for a, b in trust: if a not in indegrees: indegrees[a] = 0 if b not in indegrees: indegrees[b] = 0 if a not in outdegrees: outdegrees[a] = 0 if b not in outdegrees: outdegrees[b] = 0 outdegrees[a] += 1 indegrees[b] += 1 # If indegree == n - 1 and outdegree == 0, then we have found the town judge. townjudge = -1 for person in indegrees: if outdegrees[person] == 0: if indegrees[person] >= n - 1: townjudge = person break return townjudge","title":"Code:"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#2-course-schedule-i_1","text":"","title":"2. Course Schedule-I"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#21-topological-sorting","text":"The prerequisites[i] = [a_i, b_i] \\(\\implies\\) b_i has to come before a_i . In other words, a_i is dependent on b_i . Can you convert this problem into a graph problem? Further, which algorithm do we need to use to find a sequence that satisfies dependencies? If b_i has to come before a_i , then we add an edge from b_i to a_i . Please note the direction of the edge. We can convert this into an adjacency matrix or an adjacency list. For this problem, we are converting the graph into an adjacency matrix. Once we have converted this problem into a graph problem, we can use the algorithm we use when we need to find a sequence that satisfies some dependencies- topological sorting. When would you say that we have successfully found the sequence of courses satisfying the dependencies? When we the sequence that we get has all the courses- no course is left.","title":"2.1 Topological Sorting"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#code_1","text":"class Solution: def preprocessing(self, numCourses, prerequisites) -> list[list[int]]: adjacency_matrix = [ [0 for i in range(numCourses)] for i in range(numCourses) ] for a, b in prerequisites: adjacency_matrix[b][a] = 1 return adjacency_matrix # Implementation of Topological sort for Adjacency matrix def toposort(self, AMat): #Initialization (rows,cols) = len(AMat), len(AMat[0]) indegree = {} toposortlist = [] #Compute indegree for each vertex for c in range(cols): indegree[c] = 0 for r in range(rows): if AMat[r][c] == 1: indegree[c] = indegree[c] + 1 # Topological sort Computing process for i in range(rows): # Select the min level vertex for removing the graph which has indegree 0 zero_indegree = [k for k in range(cols) if indegree[k] == 0] if not zero_indegree:return toposortlist #Handle the case where there are no more zero indegree vertices j = zero_indegree[0] # Store the removed vertex j in toposortlist and reduce the indegree by one toposortlist.append(j) indegree[j] = indegree[j] - 1 # Reduce the indegree of each adjacent of the removed vertex j by 1 for k in range(cols): if AMat[j][k] == 1: indegree[k] = indegree[k] - 1 return(toposortlist) def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool: adjacency_matrix = self.preprocessing(numCourses, prerequisites) toposortlist = self.toposort(adjacency_matrix) if len(toposortlist) == numCourses: return True return False","title":"Code:"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#22-topological-sort-better-implementation","text":"The approach used is similar to the above approach. However, we are utilizing better data structures to increase our performance. Instead of keeping an adjacency matrix, we are utilizing a combination of doubly ended queues and adjacency lists. Here's how: - Keep a deque for vertices with zero degree queue such that the insert at end and delete from start operations are both constant time. - Keep a dictionary of indegrees which counts the indegrees for each vertex Complexity: $O(|V| + |E|)","title":"2.2 Topological Sort: Better Implementation"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#code_2","text":"from collections import deque, Counter class Solution: def canFinish(self, numCourse, prerequisites): AList = { i: [] for i in range(numCourse)} indegree = Counter() visited = { i:False for i in range(numCourse)} for course, prereq in prerequisites: AList[prereq].append(course) indegree[course] += 1 # Initialization toposortlist = [] zerodegreeq = deque() # Find the vertex with indegree 0 and added into the queue for u in range(numCourse): if indegree[u] == 0: zerodegreeq.append(u) # Topological sort Computing process while (zerodegreeq): # Remove one vertex from queue which have zero degree vertices curr_vertex = zerodegreeq.popleft() # Store the removed vertex in toposortlist and reduce the indegree by one toposortlist.append(curr_vertex) indegree[curr_vertex] = indegree[curr_vertex]-1 # Repeat for each adjacent of the removed vertex for adj_vertex in AList[curr_vertex]: # Reduce the indegree of each adjacent of the removed vertex by 1 indegree[adj_vertex] = indegree[adj_vertex] - 1 # If after reducing the degree of adjacent, it becomes zero then insert it into the queue if indegree[adj_vertex] == 0: zerodegreeq.append(adj_vertex) return len(toposortlist) == numCourse","title":"Code:"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#3-course-schedule-ii_1","text":"This problem is an exact replica of the above problem, except that we have to return a sequence that satisfies the dependencies, instead of returning a boolean of whether or not we can create such a sequence. We can use the same approaches discussed in the above question.","title":"3. Course Schedule-II"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#4-snakes-and-ladders_1","text":"","title":"4. Snakes and Ladders"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#41-using-bfs","text":"We are given a board with \\(n^2\\) cells. From any particular cell, there can be at maximum only six moves. Can we convert this structure into a graph? For example, in the first test case, assume we are at cell \\(1\\) . The next possible moves are: \\(15, 3, 4, 5, 6, 7\\) because \\(2\\) has a ladder to \\(15\\) . From cell \\(1\\) , we can make each of the next possible moves as an edge. The task is to find the least number of moves required to reach \\(n^2\\) starting from \\(1\\) . Can you identify what type of a problem this is and which algorithm we can use for this problem? It's a shortest path problem without edge weights. The algorithm that we can use for this problem is BFS. Pseudocode: - We first need to convert the board into a graph. - For every cell, check the next six cells. - If the cell has a ladder or a snake, then we need to find out where the ladder ends which is given in cell: board[row][col] - If the cell does not have a ladder or a snake, then board[row][col] will have the vaue \\(-1\\) . - Add the edge as: [cell] to board[row][cell] or the next moves. Once we have the graph, we can run BFS on this graph, which will return the shortest path.","title":"4.1 Using BFS"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#code_3","text":"","title":"Code:"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#5-sort-items-by-groups-respecting-dependencies_1","text":"","title":"5. Sort Items By Groups Respecting Dependencies"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#51-using-topological-sort","text":"We need to list a a sequential order of items such that the items belonging to the same group are listed next to each other. Each item can have a dependency such that the other item needs to be completed first- as given in the beforeItems array. It is easy to see that this is a topological ordering problem. Take a moment to think about the following: Let's say we run topological sort directly on the beforeItems. We may pass some test cases. But what test cases might we fail? Whenever we have multiple items that have zero indegree, then we have to make a choice as to which item should we take first. Let's take an example: group[0] = [1, 2] group[1] = [3, 4] indegree[1] = 0 indegree[3] = 0 indegree[2] = indegree[4] = 1 Assume: 2 needs to be come before 4, and 1 needs to come before 2. 1 -> 2 -> 4 Now, the issue will come when we are selecting between the items 1 and 3. If our algorithm chooses 3, then all the other elements belonging to group 1 should come next to 3- like: 3, 4-, and only then we'll be able to add elements from group 0- like: 3, 4, 1, 2. This violates the condition that 1 -> 2 -> 4 . To solve this problem, we need to keep a graph for the groups as well. Whenever we are choosing which item to select for the topological order, we need to first check the groups graph. Thus, we keep two graphs- one for items and one for groups . Then we run a sort of nested topological sort- the outer one for the groups graph, and the inner one for the items graph. This will give us the correct solution that respects both the group dependencies and the item dependencies.","title":"5.1 Using Topological Sort"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#psuedocode","text":"Since we are going to need to list all elements belonging to a group side by side, we will keep a dictionary of the format: group:[all items of that group] for easy retrieval. Use beforeItems array to construct both the graphs- groups and items . You can use the either an adjacency matrix or an adjacency list representation for this. Here, we are using Adjacency List representation. If items[i] needs to come before items[j] , then add edge from i to j for the items_graph . Similarly, for the group_graph , add the edge from group[i] to group[j] , since the item in i th group needs to come before the item in the j th group. Once you have the graphs, run nested topological sort as mentioned above.","title":"Psuedocode:"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#code_4","text":"# Implementation of Queue class Queue: def __init__(self): self.queue = [] def enqueue(self,v): self.queue.append(v) def isempty(self): return(self.queue == []) def dequeue(self): v = None if not self.isempty(): v = self.queue[0] self.queue = self.queue[1:] return(v) def __str__(self): return(str(self.queue)) class Solution: # Creates a dictionary that returns all elements of a particular group. Used in the main algorithm when we are listing all the items # that belong to a group side by side def get_group_wise_elements(self, group, m): group_wise_elements = { i:[] for i in range(m) } for i in range(len(group)): grp = group[i] if group[i] >= 0 else -i-1 if grp not in group_wise_elements: group_wise_elements[grp] = [] group_wise_elements[grp].append(i) return group_wise_elements # Convert the problem into two graphs- group_graph and items_graph. Along with it, return indegrees for each node in both the graphs. def preprocessing(self, beforeItems, group, m, n, groupwise_items): group_indegree, items_indegree = {}, {i:0 for i in range(n)} items_alist = {i:[] for i in range(n)} group_alist = {} for key in groupwise_items: group_alist[key] = set() group_indegree[key] = 0 for i in range(len(beforeItems)): before = beforeItems[i] for num in before: if num not in items_alist: items_alist[num] = [ ] items_alist[num].append(i) items_indegree[i] += 1 grp_num = group[num] if group[num] >= 0 else -num-1 grp_i = group[i] if group[i] >= 0 else -i-1 if grp_num != grp_i: if grp_num not in group_alist: group_alist[grp_num] = set() group_alist[grp_num].add(grp_i) for key in group_alist.keys(): group_alist[key] = list(group_alist[key]) for u in group_alist.keys(): for v in group_alist[u]: if v not in group_indegree: group_indegree[v] = 0 group_indegree[v] += 1 return items_alist, group_alist, items_indegree, group_indegree # Run the actual nested topological sorting algorithm def lpath(self, items_alist, group_alist, items_indegree, group_indegree, groupwise_items, n, group): output = [ ] grp_queue = Queue() items_queue = Queue() for grp in group_indegree: if group_indegree[grp] == 0: grp_queue.enqueue(grp) # Outer topological sort is for groups while not grp_queue.isempty(): curr_grp = grp_queue.dequeue() group_indegree[curr_grp] -= 1 for adj_grp in group_alist[curr_grp]: # Reduce the indegree of each adjacent group of the removed vertex by 1 group_indegree[adj_grp] -= 1 # If after reducing the degree of adjacent group, it becomes zero then insert it into the group queue if group_indegree[adj_grp] == 0 : grp_queue.enqueue(adj_grp) for i in groupwise_items[curr_grp]: if items_indegree[i] == 0 : items_queue.enqueue(i) # Inner topological sort is for the items while (not items_queue.isempty()): # Remove one vertex from items queue which have zero degree items and reduce the indegree by 1 curr_vertex = items_queue.dequeue() output.append(curr_vertex) items_indegree[curr_vertex] = items_indegree[curr_vertex] - 1 # Repeat for each adjacent of the removed item for adj_vertex in items_alist[curr_vertex]: # Reduce the indegree of each adjacent of the removed item by 1 items_indegree[adj_vertex] = items_indegree[adj_vertex] - 1 # If after reducing the degree of adjacent item, it becomes zero then insert it into the items queue if items_indegree[adj_vertex] == 0 and group[adj_vertex] == curr_grp: items_queue.enqueue(adj_vertex) if len(output) != n: return [] return output def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]: group_wise_items = self.get_group_wise_elements(group, m) items_alist, group_alist, items_indegree, group_indegree = self.preprocessing(beforeItems,group, m, n, group_wise_items) return self.lpath(items_alist, group_alist, items_indegree, group_indegree, group_wise_items, n, group)","title":"Code:"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#6-find-if-path-exists_1","text":"","title":"6. Find If Path Exists"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#61-using-bfs","text":"What is the question asking you to do? - We need to find out whether we can reach a particular destination from the given source node. That is, it's a reachability problem. Can you convert the given edges list into an adjacency list or an adjacency matrix representation? - Each edges[i] = [u_i, v_i] represents a bidirectional edge, which means there is an edge from u to v , and v to u . - So we can iterate over the entire edges array, and add the two edges for every edges[i] . Here's the code snippet for converting the edges array into an adjacency list: for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) Once we have the adjacency list, which algorithm will give us whether we can reach destination from the source ? - We can use either BFS or DFS. For this solution, we are using BFS.","title":"6.1 Using BFS"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#code_5","text":"Note: For a better, more concise code, we have used the deque data structure from the collections module in Python. We can use it to implement a queue used in BFS. from collections import deque class Solution: def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool: adj_list = { i:[ ] for i in range(n) } visited = set() for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) queue = deque([source]) visited.add(source) while queue: vertex = queue.popleft() if vertex == destination: return True for neighbor in adj_list[vertex]: if neighbor not in visited: queue.append(neighbor) visited.add(neighbor) return False","title":"Code:"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#7-number-of-provinces_1","text":"","title":"7. Number of Provinces"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#71-using-bfs","text":"We are given a matrix isConnected , whose [i][j] th entry tells us whether there is an undirected edge from i to j . We can interpret this isConnected matrix as an adjacency matrix. A province is a set of vertices that are connected to each other. We are asked to find the number of provinces from the matrix. Can you identify the type of the problem? - The problem is about finding the number of connected components from the graph. Can you identify which algorithm we can use to solve this problem? - We can use BFS or DFS to solve this problem. For this solution, we will use BFS.","title":"7.1 Using BFS"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#code_6","text":"from collections import deque class Solution: def get_neighbors(self, AMat, vertex): \"\"\"Given an adjacency matrix and a vertex, returns all neighbors for that vertex\"\"\" neighbors = [] for i in range(len(AMat)): if AMat[vertex][i] == 1: neighbors.append(i) return neighbors def BFS(self, AMat, source): \"\"\" Runs BFS from a given source vertex and returns the set of vertices visited in that run of BFS. That is, each run of the BFS will give us one province, or one connected component. \"\"\" visited = set() queue = deque([source]) # Initialize the queue with the source vertex visited.add(source) while queue: vertex = queue.popleft() neighbors = self.get_neighbors(AMat, vertex) # Pass both AMat and vertex for neighbor in neighbors: if neighbor not in visited: queue.append(neighbor) visited.add(neighbor) return visited def findCircleNum(self, isConnected): # Initially, every vertex gets an invalid component number components = {i: -1 for i in range(len(isConnected))} # Keep track of the component number and the number of vertices already visited across BFS runs component_number = 0 seen = 0 while seen < len(isConnected): startv = min([i for i in range(len(isConnected)) if components[i] == -1]) visited = self.BFS(isConnected, startv) # For every vertex that was visited in the current run of BFS, update its component number and update # the number of vertices seen. for v in visited: components[v] = component_number seen += 1 # Increment component number such that for the next run of BFS, # a different component number will be assigned component_number += 1 return component_number","title":"Code:"},{"location":"Greedy/Questions/","text":"Problems on Greedy Algorithms 1. N Meetings in One Room 2. Activity Selection 3. Minimum Number of Coins 4. Jump Game 5. Jump Game-II 1. N Meetings in One Room 1.1 Using Greedy Approach The question is asking us to find out the maximum number of meetings that could be scheduled without conflicts given two arrays- start and end . Can you find out what type of problem this is? - It is a classic interval scheduling problem. The way we go about solving such problems is by sorting the schedules based on their end times and then picking those meetings that don't conflict. Here's how we can approach the solution: - Combine the start and end arrays into a single array of the form: [start_i, end_i] - Sort the list based on the times - Keep track of the end time of the last meet. - If the start of the current meet overlaps with the previous end time, then we skip the meet. - Else, we increment the meeting counter, and update the previous end time as the end time of the current meet. Code: class Solution: def maximumMeetings(self,n,start,end): # code here times = [ [start[i], end[i]] for i in range(n)] # Sort based on end times times.sort(key=lambda x:x[1]) count = 0 prev_endtime = None for start_time, end_time in times: # First meeting if not prev_endtime: prev_endtime = end_time count += 1 else: # Check if the previous meet's endtime clashes with the start time of the current meet if prev_endtime < start_time: prev_endtime = end_time count += 1 return count 2. Activity Selection 2.1 Greedy Approach Same approach as the above question. Code: class Solution: def activitySelection(self,n,start,end): # Rearrange the start and end arrays into a single array arr = [ [start[i], end[i]] for i in range(n) ] # Sort based on end times arr.sort(key=lambda x:x[1]) count = 0 prev_endtime = None for start_time, end_time in arr: # First activity if not prev_endtime: prev_endtime = end_time count += 1 else: # Check if the previous activity's endtime clashes with the start time of the current activity if start_time > prev_endtime: count += 1 prev_endtime = end_time return count 3. Minimum Number of Coins 3.1 Using Greedy Note: In general, we cannot guarantee that greedy algorithm will produce correct output. However, in the case of this question, we can use greedy approach. Because the number of smaller denominations is bounded by the fact that we can use larger denominations to represent the smaller denominations. For example, the number of coins of denomination 2 cannot be more than 2, because if their number is 3, then we can replace it with one coin of denomination 5 and one coin of denomination 1. That is, with fewer coins of larger denomination, we can represent more coins of lower denomination. Thus, we can choose a greedy approach: - Keep on subtracting the coin of largest denomination. Then move on to second largest, then third, and so on, till you reach 0. - Every time you subtract a coin / note, add the denomination to a results array. Code: class Solution: def minPartition(self, N): denominations = [2000, 500, 200, 100, 50, 20, 10, 5, 2, 1] # List of denominations in descending order result = [] # List to store the coins/notes used for coin in denominations: while N >= coin: # Check how many times the coin/note can fit into the remaining amount N -= coin # Subtract the coin/note value from target result.append(coin) # Add the coin/note to the result list return result 4. Jump Game 4.1 Using Greedy Approach The question is asking us to find out whether the last index can be reached or not using the given nums array. nums[i] corresponds to the maximum jump we can take from the ith index. We can solve this problem using the Greedy Approach. Here's how: - We'll keep a max_jump variable, that acts like a flagpost. It tells what is the maximum index that we can reach based on the values of nums[i] we have seen so far. - Then we iterate over all the values of nums . - Whenever this max_index goes beyond the length of the array, we will return True . - For every value in nums , we update the max_jump as: max_jump = max(max_jump, nums[i] + i) - But it is also possible that we cannot reach the last index. Consider the example nums = [1, 0, 2] . In this example, once we reach the 1st index, there is no way to move forward. Can we capture this in a condition? - Whenever i > max_jump , that means we have reached a place from where we cannot proceed further. Thus, we can return False here. Code: class Solution: def canJump(self, nums: List[int]) -> bool: max_jump = 0 for i in range(len(nums)): # i <= max_jump -> case to check [1, 0, 2] like condition # nums[i] + i > max_jump to update the jump if i <= max_jump and nums[i] + i > max_jump : max_jump = nums[i] + i # Check whether you can reach the last index or not. return max_jump >= len(nums) - 1 5 Jump Game-II Using Greedy Approach Code: class Solution: def jump(self, nums: List[int]) -> bool: n = len(nums) if n == 1: return 0 jump_count = 0 current_end = 0 max_jump = 0 for i in range(n - 1): max_jump = max(max_jump, i + nums[i]) # When we reach the end of the current jump. For example, [3, 5, 1, 1, 1, 1] if i == current_end: jump_count += 1 current_end = max_jump # If we can reach the end, break early if current_end >= n - 1: break return jump_count","title":"Problems on Greedy Algorithms"},{"location":"Greedy/Questions/#problems-on-greedy-algorithms","text":"","title":"Problems on Greedy Algorithms"},{"location":"Greedy/Questions/#1-n-meetings-in-one-room","text":"","title":"1. N Meetings in One Room"},{"location":"Greedy/Questions/#2-activity-selection","text":"","title":"2. Activity Selection"},{"location":"Greedy/Questions/#3-minimum-number-of-coins","text":"","title":"3. Minimum Number of Coins"},{"location":"Greedy/Questions/#4-jump-game","text":"","title":"4. Jump Game"},{"location":"Greedy/Questions/#5-jump-game-ii","text":"","title":"5. Jump Game-II"},{"location":"Greedy/Questions/#1-n-meetings-in-one-room_1","text":"","title":"1. N Meetings in One Room"},{"location":"Greedy/Questions/#11-using-greedy-approach","text":"The question is asking us to find out the maximum number of meetings that could be scheduled without conflicts given two arrays- start and end . Can you find out what type of problem this is? - It is a classic interval scheduling problem. The way we go about solving such problems is by sorting the schedules based on their end times and then picking those meetings that don't conflict. Here's how we can approach the solution: - Combine the start and end arrays into a single array of the form: [start_i, end_i] - Sort the list based on the times - Keep track of the end time of the last meet. - If the start of the current meet overlaps with the previous end time, then we skip the meet. - Else, we increment the meeting counter, and update the previous end time as the end time of the current meet.","title":"1.1 Using Greedy Approach"},{"location":"Greedy/Questions/#code","text":"class Solution: def maximumMeetings(self,n,start,end): # code here times = [ [start[i], end[i]] for i in range(n)] # Sort based on end times times.sort(key=lambda x:x[1]) count = 0 prev_endtime = None for start_time, end_time in times: # First meeting if not prev_endtime: prev_endtime = end_time count += 1 else: # Check if the previous meet's endtime clashes with the start time of the current meet if prev_endtime < start_time: prev_endtime = end_time count += 1 return count","title":"Code:"},{"location":"Greedy/Questions/#2-activity-selection_1","text":"","title":"2. Activity Selection"},{"location":"Greedy/Questions/#21-greedy-approach","text":"Same approach as the above question.","title":"2.1 Greedy Approach"},{"location":"Greedy/Questions/#code_1","text":"class Solution: def activitySelection(self,n,start,end): # Rearrange the start and end arrays into a single array arr = [ [start[i], end[i]] for i in range(n) ] # Sort based on end times arr.sort(key=lambda x:x[1]) count = 0 prev_endtime = None for start_time, end_time in arr: # First activity if not prev_endtime: prev_endtime = end_time count += 1 else: # Check if the previous activity's endtime clashes with the start time of the current activity if start_time > prev_endtime: count += 1 prev_endtime = end_time return count","title":"Code:"},{"location":"Greedy/Questions/#3-minimum-number-of-coins_1","text":"","title":"3. Minimum Number of Coins"},{"location":"Greedy/Questions/#31-using-greedy","text":"Note: In general, we cannot guarantee that greedy algorithm will produce correct output. However, in the case of this question, we can use greedy approach. Because the number of smaller denominations is bounded by the fact that we can use larger denominations to represent the smaller denominations. For example, the number of coins of denomination 2 cannot be more than 2, because if their number is 3, then we can replace it with one coin of denomination 5 and one coin of denomination 1. That is, with fewer coins of larger denomination, we can represent more coins of lower denomination. Thus, we can choose a greedy approach: - Keep on subtracting the coin of largest denomination. Then move on to second largest, then third, and so on, till you reach 0. - Every time you subtract a coin / note, add the denomination to a results array.","title":"3.1 Using Greedy"},{"location":"Greedy/Questions/#code_2","text":"class Solution: def minPartition(self, N): denominations = [2000, 500, 200, 100, 50, 20, 10, 5, 2, 1] # List of denominations in descending order result = [] # List to store the coins/notes used for coin in denominations: while N >= coin: # Check how many times the coin/note can fit into the remaining amount N -= coin # Subtract the coin/note value from target result.append(coin) # Add the coin/note to the result list return result","title":"Code:"},{"location":"Greedy/Questions/#4-jump-game_1","text":"","title":"4. Jump Game"},{"location":"Greedy/Questions/#41-using-greedy-approach","text":"The question is asking us to find out whether the last index can be reached or not using the given nums array. nums[i] corresponds to the maximum jump we can take from the ith index. We can solve this problem using the Greedy Approach. Here's how: - We'll keep a max_jump variable, that acts like a flagpost. It tells what is the maximum index that we can reach based on the values of nums[i] we have seen so far. - Then we iterate over all the values of nums . - Whenever this max_index goes beyond the length of the array, we will return True . - For every value in nums , we update the max_jump as: max_jump = max(max_jump, nums[i] + i) - But it is also possible that we cannot reach the last index. Consider the example nums = [1, 0, 2] . In this example, once we reach the 1st index, there is no way to move forward. Can we capture this in a condition? - Whenever i > max_jump , that means we have reached a place from where we cannot proceed further. Thus, we can return False here.","title":"4.1 Using Greedy Approach"},{"location":"Greedy/Questions/#code_3","text":"class Solution: def canJump(self, nums: List[int]) -> bool: max_jump = 0 for i in range(len(nums)): # i <= max_jump -> case to check [1, 0, 2] like condition # nums[i] + i > max_jump to update the jump if i <= max_jump and nums[i] + i > max_jump : max_jump = nums[i] + i # Check whether you can reach the last index or not. return max_jump >= len(nums) - 1","title":"Code:"},{"location":"Greedy/Questions/#5-jump-game-ii_1","text":"","title":"5 Jump Game-II"},{"location":"Greedy/Questions/#using-greedy-approach","text":"","title":"Using Greedy Approach"},{"location":"Greedy/Questions/#code_4","text":"class Solution: def jump(self, nums: List[int]) -> bool: n = len(nums) if n == 1: return 0 jump_count = 0 current_end = 0 max_jump = 0 for i in range(n - 1): max_jump = max(max_jump, i + nums[i]) # When we reach the end of the current jump. For example, [3, 5, 1, 1, 1, 1] if i == current_end: jump_count += 1 current_end = max_jump # If we can reach the end, break early if current_end >= n - 1: break return jump_count","title":"Code:"},{"location":"Heaps%20and%20Trees/Questions/","text":"Leet Code Problems on Heaps and Trees 1. Validate Binary Search Tree 2. Network Delay Time 3. Maximum Spending After Buying Items 1. Validate Binary Search Tree 1.1 Using Inorder Traversal We know that the inorder traversal of a binary search tree gives a sorted list of elements. Can you try to reason as to why this can be helpful to find out whether we have a valid binary search tree or not? If the tree is a valid binary search tree, then it's inorder traversal will be a valid sorted list. But on the other hand, if the tree is not a valid binary search tree, then it's inorder traversal will not be a sorted list. So, that's what we do: - Do the inorder traversal on the tree - Go over the elements in the list to check if the list is in a sorted order: Comparing current element with the previous element can be sufficient for this. Time complexity: \\(O(n)\\) Code: class Solution: def isValidBST(self, root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" tree = self.inorder_traversal(root) # Do inorder traversal # Base Case: if tree has just one element, then it is a valid BST if len(tree) <= 1: return True # If the list is sorted, then the L[i - 1] will always be smaller than L[i] for i in range(1, len(tree)): if tree[i - 1] >= tree[i]: return False return True def inorder_traversal(self, root): if not root: return [] return self.inorder_traversal(root.left) + [root.val] + self.inorder_traversal(root.right) 2. Network Delay Time 2.1 Using Dijkstra We are given an array times where times[i] = [u_i, v_i, w_i] , where u_i is the source node, v_i is the destination and w_i is the weight of that edge. It is clear that this is a directed graph. Can you convert the times array into a more graph suited representation like an adjacency list or an adjacency matrix? - Here's the code snippet that can accomplish this: WList = { i:[] for i in range(1, n+1) } visited = {i : False for i in range(1, n+1)} for u, v, w in times: WList[u].append((v, w)) The question is asking us to find out the minimum time it will take for the signal to reach all nodes if started from the node k . Can you identify what type of a problem this is? - It is a shortest path problem. Since time will be non-negative, we can use Dijkstra here. Observe the following: - The minimum time taken to reach all vertices is the same as the minimum time it would take to \"burn\" the last reached vertex when using Dijkstra. This is the same as the maximum shortest path after running Dijkstra. Code: import heapq class Solution: def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int: # Convert the \"times\" array into an adjacency list WList = { i:[] for i in range(1, n+1) } visited = {i : False for i in range(1, n+1)} for u, v, w in times: WList[u].append((v, w)) # Run Dijkstra on it dist = {node: float('inf') for node in range(1, n+1)} dist[k] = 0 # Priority queue heap = [(0, k)] # (distance, node) while heap: current_dist, node = heapq.heappop(heap) # By default, heapq.heappop(heap) returns the minimum element from heap visited[node] = True if current_dist > dist[node]: continue for neighbor, weight in WList[node]: if visited[neighbor]: continue distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) # The minimum time taken for the signal to reach all the vertices, is the same as the last vertex to get \"burnt\" in Dijkstra's algorithm, which is the same as # maximum of shortest distance values max_dist = max(dist.values()) return max_dist if max_dist != float('inf') else -1 # Check if all nodes can be reached or not. 3 Maximum Spending After Buying Items 3.1 Brute Force We are given an \\(m \\times n\\) matrix, and we can take out values only from the right end of each row. Further, the ammount spent on a day is defined as day number * value of the product . To maximize spending over m * n days, can you think of which element do we need to remove first? They should be the minimum elements, because the spending can be maximized if larger values are taken near the end of m * n th day. So, from each rows' last column, we need to pop the one that is the smallest. Here's the pseudocode: - Keep a variable for max spending. - Iterate day counter $ m \\times n$ times - Keep a minimum value variable. - For every row, compare the last element of it with this minimum value - Multiply the minimum with the day counter and add this to the max spending. Time Complexity: \\(O(m^2n)\\) Code: class Solution: def maxSpending(self, values: List[List[int]]) -> int: m, n = len(values), len(values[0]) max_spending = 0 # Iterate over all days for day in range(1, m*n + 1): # Find out the minimum val of the product that can be bought min_val, min_index = float('inf'), None for j in range(m): # Check if the row is not empty # And since only rightmost product can be bought, only compare L[j][-1]th element if values[j] and values[j][-1] < min_val: min_val = values[j][-1] min_index = j # Pop the minimum value product and add the value to answer product_val = values[min_index].pop() max_spending += day * product_val return max_spending 3.2 Using Minheaps We still need to find the minimum of the rightmost elements and add it to the counter. Can you think of a data structure that lets us efficiently remove the minimum element? Minheaps can be used. Let's see how: Let's assume we have the values array as follows: $$ \\begin{bmatrix} 4 & 3 \\ 7 & 5 \\end{bmatrix} $$ The heap will consist of all the rightmost elements: $heap = [ 3, 5] $. From this minheap, we can remove the minimum easily. After delete_min operation, heap looks like: $ heap = [ 5] $ and the matrix values looks like this: \\[ \\begin{bmatrix} 4 \\\\ 7 & 5 \\end{bmatrix} \\] Now, for the first row, the rightmost element is \\(4\\) . We need to add it to the minheap for the next iteration for this approach to work well as this: $ heap = [4, 5]$. To do this well, we'll keep track of the row_index to note from which row was this minimum popped. Here's the pseudocode: Keep the max spending variable Create the minheap for the rightmost elements. Iterate day counter over $ m \\times n$ times Remove the minimum from the Minheap. From the row from which the minimum was popped, insert the new last element in the heap. Time Complexity: \\(O(mn \\cdot log(m))\\) Code: class Minheap: def __init__(self): self.A = [] def min_heapify(self,k): l = 2 * k + 1 r = 2 * k + 2 smallest = k if l < len(self.A) and self.A[l][0] < self.A[smallest][0]: smallest = l if r < len(self.A) and self.A[r][0] < self.A[smallest][0]: smallest = r if smallest != k: self.A[k], self.A[smallest] = self.A[smallest], self.A[k] self.min_heapify(smallest) def delete_min(self): item = None if self.A != []: self.A[0],self.A[-1] = self.A[-1],self.A[0] item = self.A.pop() self.min_heapify(0) return item def insert_in_minheap(self,d): self.A.append(d) index = len(self.A)-1 while index > 0: parent = (index-1)//2 if self.A[index][0] < self.A[parent][0]: self.A[index],self.A[parent] = self.A[parent],self.A[index] index = parent else: break class Solution: def maxSpending(self, values: List[List[int]]) -> int: m, n = len(values), len(values[0]) # Using Priority Queues- O(mn log(m)) heap, max_spending = Minheap(), 0 # Create a minimum heap from the last elements for i in range(m): heap.insert_in_minheap([values[i][-1], i]) # Every elem in heap is: [value, row_number] # Iterate over days for day in range(1, m*n+1): min_val, min_store_index = heap.delete_min() # Delete based on value values[min_store_index].pop() # Pop from values array max_spending += day * min_val if values[min_store_index]: heap.insert_in_minheap([values[min_store_index][-1], min_store_index]) return max_spending","title":"Leet Code Problems on Heaps and Trees"},{"location":"Heaps%20and%20Trees/Questions/#leet-code-problems-on-heaps-and-trees","text":"","title":"Leet Code Problems on Heaps and Trees"},{"location":"Heaps%20and%20Trees/Questions/#1-validate-binary-search-tree","text":"","title":"1. Validate Binary Search Tree"},{"location":"Heaps%20and%20Trees/Questions/#2-network-delay-time","text":"","title":"2. Network Delay Time"},{"location":"Heaps%20and%20Trees/Questions/#3-maximum-spending-after-buying-items","text":"","title":"3. Maximum Spending After Buying Items"},{"location":"Heaps%20and%20Trees/Questions/#1-validate-binary-search-tree_1","text":"","title":"1. Validate Binary Search Tree"},{"location":"Heaps%20and%20Trees/Questions/#11-using-inorder-traversal","text":"We know that the inorder traversal of a binary search tree gives a sorted list of elements. Can you try to reason as to why this can be helpful to find out whether we have a valid binary search tree or not? If the tree is a valid binary search tree, then it's inorder traversal will be a valid sorted list. But on the other hand, if the tree is not a valid binary search tree, then it's inorder traversal will not be a sorted list. So, that's what we do: - Do the inorder traversal on the tree - Go over the elements in the list to check if the list is in a sorted order: Comparing current element with the previous element can be sufficient for this. Time complexity: \\(O(n)\\)","title":"1.1 Using Inorder Traversal"},{"location":"Heaps%20and%20Trees/Questions/#code","text":"class Solution: def isValidBST(self, root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" tree = self.inorder_traversal(root) # Do inorder traversal # Base Case: if tree has just one element, then it is a valid BST if len(tree) <= 1: return True # If the list is sorted, then the L[i - 1] will always be smaller than L[i] for i in range(1, len(tree)): if tree[i - 1] >= tree[i]: return False return True def inorder_traversal(self, root): if not root: return [] return self.inorder_traversal(root.left) + [root.val] + self.inorder_traversal(root.right)","title":"Code:"},{"location":"Heaps%20and%20Trees/Questions/#2-network-delay-time_1","text":"","title":"2. Network Delay Time"},{"location":"Heaps%20and%20Trees/Questions/#21-using-dijkstra","text":"We are given an array times where times[i] = [u_i, v_i, w_i] , where u_i is the source node, v_i is the destination and w_i is the weight of that edge. It is clear that this is a directed graph. Can you convert the times array into a more graph suited representation like an adjacency list or an adjacency matrix? - Here's the code snippet that can accomplish this: WList = { i:[] for i in range(1, n+1) } visited = {i : False for i in range(1, n+1)} for u, v, w in times: WList[u].append((v, w)) The question is asking us to find out the minimum time it will take for the signal to reach all nodes if started from the node k . Can you identify what type of a problem this is? - It is a shortest path problem. Since time will be non-negative, we can use Dijkstra here. Observe the following: - The minimum time taken to reach all vertices is the same as the minimum time it would take to \"burn\" the last reached vertex when using Dijkstra. This is the same as the maximum shortest path after running Dijkstra.","title":"2.1 Using Dijkstra"},{"location":"Heaps%20and%20Trees/Questions/#code_1","text":"import heapq class Solution: def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int: # Convert the \"times\" array into an adjacency list WList = { i:[] for i in range(1, n+1) } visited = {i : False for i in range(1, n+1)} for u, v, w in times: WList[u].append((v, w)) # Run Dijkstra on it dist = {node: float('inf') for node in range(1, n+1)} dist[k] = 0 # Priority queue heap = [(0, k)] # (distance, node) while heap: current_dist, node = heapq.heappop(heap) # By default, heapq.heappop(heap) returns the minimum element from heap visited[node] = True if current_dist > dist[node]: continue for neighbor, weight in WList[node]: if visited[neighbor]: continue distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) # The minimum time taken for the signal to reach all the vertices, is the same as the last vertex to get \"burnt\" in Dijkstra's algorithm, which is the same as # maximum of shortest distance values max_dist = max(dist.values()) return max_dist if max_dist != float('inf') else -1 # Check if all nodes can be reached or not.","title":"Code:"},{"location":"Heaps%20and%20Trees/Questions/#3-maximum-spending-after-buying-items_1","text":"","title":"3 Maximum Spending After Buying Items"},{"location":"Heaps%20and%20Trees/Questions/#31-brute-force","text":"We are given an \\(m \\times n\\) matrix, and we can take out values only from the right end of each row. Further, the ammount spent on a day is defined as day number * value of the product . To maximize spending over m * n days, can you think of which element do we need to remove first? They should be the minimum elements, because the spending can be maximized if larger values are taken near the end of m * n th day. So, from each rows' last column, we need to pop the one that is the smallest. Here's the pseudocode: - Keep a variable for max spending. - Iterate day counter $ m \\times n$ times - Keep a minimum value variable. - For every row, compare the last element of it with this minimum value - Multiply the minimum with the day counter and add this to the max spending. Time Complexity: \\(O(m^2n)\\)","title":"3.1 Brute Force"},{"location":"Heaps%20and%20Trees/Questions/#code_2","text":"class Solution: def maxSpending(self, values: List[List[int]]) -> int: m, n = len(values), len(values[0]) max_spending = 0 # Iterate over all days for day in range(1, m*n + 1): # Find out the minimum val of the product that can be bought min_val, min_index = float('inf'), None for j in range(m): # Check if the row is not empty # And since only rightmost product can be bought, only compare L[j][-1]th element if values[j] and values[j][-1] < min_val: min_val = values[j][-1] min_index = j # Pop the minimum value product and add the value to answer product_val = values[min_index].pop() max_spending += day * product_val return max_spending","title":"Code:"},{"location":"Heaps%20and%20Trees/Questions/#32-using-minheaps","text":"We still need to find the minimum of the rightmost elements and add it to the counter. Can you think of a data structure that lets us efficiently remove the minimum element? Minheaps can be used. Let's see how: Let's assume we have the values array as follows: $$ \\begin{bmatrix} 4 & 3 \\ 7 & 5 \\end{bmatrix} $$ The heap will consist of all the rightmost elements: $heap = [ 3, 5] $. From this minheap, we can remove the minimum easily. After delete_min operation, heap looks like: $ heap = [ 5] $ and the matrix values looks like this: \\[ \\begin{bmatrix} 4 \\\\ 7 & 5 \\end{bmatrix} \\] Now, for the first row, the rightmost element is \\(4\\) . We need to add it to the minheap for the next iteration for this approach to work well as this: $ heap = [4, 5]$. To do this well, we'll keep track of the row_index to note from which row was this minimum popped. Here's the pseudocode: Keep the max spending variable Create the minheap for the rightmost elements. Iterate day counter over $ m \\times n$ times Remove the minimum from the Minheap. From the row from which the minimum was popped, insert the new last element in the heap. Time Complexity: \\(O(mn \\cdot log(m))\\)","title":"3.2 Using Minheaps"},{"location":"Heaps%20and%20Trees/Questions/#code_3","text":"class Minheap: def __init__(self): self.A = [] def min_heapify(self,k): l = 2 * k + 1 r = 2 * k + 2 smallest = k if l < len(self.A) and self.A[l][0] < self.A[smallest][0]: smallest = l if r < len(self.A) and self.A[r][0] < self.A[smallest][0]: smallest = r if smallest != k: self.A[k], self.A[smallest] = self.A[smallest], self.A[k] self.min_heapify(smallest) def delete_min(self): item = None if self.A != []: self.A[0],self.A[-1] = self.A[-1],self.A[0] item = self.A.pop() self.min_heapify(0) return item def insert_in_minheap(self,d): self.A.append(d) index = len(self.A)-1 while index > 0: parent = (index-1)//2 if self.A[index][0] < self.A[parent][0]: self.A[index],self.A[parent] = self.A[parent],self.A[index] index = parent else: break class Solution: def maxSpending(self, values: List[List[int]]) -> int: m, n = len(values), len(values[0]) # Using Priority Queues- O(mn log(m)) heap, max_spending = Minheap(), 0 # Create a minimum heap from the last elements for i in range(m): heap.insert_in_minheap([values[i][-1], i]) # Every elem in heap is: [value, row_number] # Iterate over days for day in range(1, m*n+1): min_val, min_store_index = heap.delete_min() # Delete based on value values[min_store_index].pop() # Pop from values array max_spending += day * min_val if values[min_store_index]: heap.insert_in_minheap([values[min_store_index][-1], min_store_index]) return max_spending","title":"Code:"},{"location":"Shortest%20Paths%20and%20Minimum%20Spanning%20Trees/Questions/","text":"Leet Code Problems on Shortest Path and Minimum Cost Spanning Trees 1. Min Cost To Connect All Points 2. Cheapest Flight Within K Stops 1. Min Cost To Connect All Points 1.1 Minimum Cost Spanning Trees The question is asking for the minimum cost to connect all the points. Can you identify what type of a problem this is? It is a MCST problem! How can you convert the given points into a graph? Each point can represent a node in the graph. The edges are the distances between any two points in the graph. So, it will be a complete graph- where each node is connected to every other node with some cost. Run a nested loop: For each point For every other point, Compute the distance and store the edge in an adjacency matrix or an adjacency list Once we have the graph representation, we can run either or Prim's or Kruskal's algorithm on this graph to get the Minimum Cost Spanning Tree's edges. To compute the minimum cost, iterate over the Tree edges and sum the edge weights Code: def kruskal(WList): \"\"\"Kruskal's as per the PDSA book\"\"\" (edges,component,TE) = ([],{},[]) for u in WList.keys(): edges.extend([(d,u,v) for (v,d) in WList[u]]) component[u] = u edges.sort() for (d,u,v) in edges: if component[u] != component[v]: TE.append((u,v, d)) c = component[u] for w in WList.keys(): if component[w] == c: component[w] = component[v] def compute_min_cost(TE) -> int: # Compute the Minimum Cost based on Tree Edges min_cost = 0 for u, v, d in TE: min_cost += d return(min_cost) class Solution: def minCostConnectPoints(self, points: List[List[int]]) -> int: # Init Adjacency Matrix AList = { i : [] for i in range(len(points))} # Each point can be connected to every other point and their manhattan distance can be computed. for i in range(len(points)): x1, y1 = points[i][0], points[i][1] for j in range(i + 1, len(points)): x2, y2 = points[j][0], points[j][1] dist = abs(x1 - x2) + abs(y1 - y2) # Distance from point i to j is same as from j to i. So init both entries AList[i].append((j, dist)) AList[j].append((i, dist)) tree_edges = kruskal(AList) minimum_cost = compute_min_cost(tree_edges) return minimum_cost 2. Cheapest Flight Within K Stops 2.1 Using Bellman-Ford","title":"Leet Code Problems on Shortest Path and Minimum Cost Spanning Trees"},{"location":"Shortest%20Paths%20and%20Minimum%20Spanning%20Trees/Questions/#leet-code-problems-on-shortest-path-and-minimum-cost-spanning-trees","text":"","title":"Leet Code Problems on Shortest Path and Minimum Cost Spanning Trees"},{"location":"Shortest%20Paths%20and%20Minimum%20Spanning%20Trees/Questions/#1-min-cost-to-connect-all-points","text":"","title":"1. Min Cost To Connect All Points"},{"location":"Shortest%20Paths%20and%20Minimum%20Spanning%20Trees/Questions/#2-cheapest-flight-within-k-stops","text":"","title":"2. Cheapest Flight Within K Stops"},{"location":"Shortest%20Paths%20and%20Minimum%20Spanning%20Trees/Questions/#1-min-cost-to-connect-all-points_1","text":"","title":"1. Min Cost To Connect All Points"},{"location":"Shortest%20Paths%20and%20Minimum%20Spanning%20Trees/Questions/#11-minimum-cost-spanning-trees","text":"The question is asking for the minimum cost to connect all the points. Can you identify what type of a problem this is? It is a MCST problem! How can you convert the given points into a graph? Each point can represent a node in the graph. The edges are the distances between any two points in the graph. So, it will be a complete graph- where each node is connected to every other node with some cost. Run a nested loop: For each point For every other point, Compute the distance and store the edge in an adjacency matrix or an adjacency list Once we have the graph representation, we can run either or Prim's or Kruskal's algorithm on this graph to get the Minimum Cost Spanning Tree's edges. To compute the minimum cost, iterate over the Tree edges and sum the edge weights","title":"1.1 Minimum Cost Spanning Trees"},{"location":"Shortest%20Paths%20and%20Minimum%20Spanning%20Trees/Questions/#code","text":"def kruskal(WList): \"\"\"Kruskal's as per the PDSA book\"\"\" (edges,component,TE) = ([],{},[]) for u in WList.keys(): edges.extend([(d,u,v) for (v,d) in WList[u]]) component[u] = u edges.sort() for (d,u,v) in edges: if component[u] != component[v]: TE.append((u,v, d)) c = component[u] for w in WList.keys(): if component[w] == c: component[w] = component[v] def compute_min_cost(TE) -> int: # Compute the Minimum Cost based on Tree Edges min_cost = 0 for u, v, d in TE: min_cost += d return(min_cost) class Solution: def minCostConnectPoints(self, points: List[List[int]]) -> int: # Init Adjacency Matrix AList = { i : [] for i in range(len(points))} # Each point can be connected to every other point and their manhattan distance can be computed. for i in range(len(points)): x1, y1 = points[i][0], points[i][1] for j in range(i + 1, len(points)): x2, y2 = points[j][0], points[j][1] dist = abs(x1 - x2) + abs(y1 - y2) # Distance from point i to j is same as from j to i. So init both entries AList[i].append((j, dist)) AList[j].append((i, dist)) tree_edges = kruskal(AList) minimum_cost = compute_min_cost(tree_edges) return minimum_cost","title":"Code:"},{"location":"Shortest%20Paths%20and%20Minimum%20Spanning%20Trees/Questions/#2-cheapest-flight-within-k-stops_1","text":"","title":"2. Cheapest Flight Within K Stops"},{"location":"Shortest%20Paths%20and%20Minimum%20Spanning%20Trees/Questions/#21-using-bellman-ford","text":"","title":"2.1 Using Bellman-Ford"},{"location":"Sorting%20and%20Searching/Questions/","text":"Problems on Sorting and Searching 1. Longest Subsequence With Limited Sum 2. Top K Frequent Elements 3. Sort Colors 4. Merge Intervals 1. Longest Subsequence With Limited Sum 1.1: Brute Force To find out the maximum number of elements less than or equal to some number, just add the smallest numbers. Sort the list first. For every query in queries , find out how many elements can be added by iterating over the array nums . Complexity: $ O(mn) $ Code: class Solution(object): def answerQueries(self, nums, queries): \"\"\" :type nums: List[int] :type queries: List[int] :rtype: List[int] \"\"\" answer = [ 0 for i in range(len(queries))] nums.sort() # Sort so that adding smallest elements is easier for i in range(len(queries)): query = queries[i] index, count, total = 0, 0, 0 # For every query, keep adding the smallest element to get the maximum number of # elements whose total is less than or equal to that query while total <= query and index < len(nums): if total + nums[index] > query: answer[i] = count break else: total += nums[index] index += 1 count += 1 answer[i] = count return answer 1.2 Prefix Sum Sort the list first. Keep a prefix_sum array that has this interpretation: i th index stores the sum of first i smallest elements. Note that this array will be sorted. For each queries[i] , use binary search on prefix_sum to find out the largest element less than equal to queries[i] Complexity: \\(O(nlogn)\\) Code: class Solution: def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]: answer = [0 for i in range(len(queries))] # O(n) nums.sort() # O(nlogn) prefix_sum = [ ] # O(n) for i in range(len(nums)): prefix_sum.append(nums[0]) if i == 0 else prefix_sum.append(prefix_sum[i - 1] + nums[i]) # O (m log n) for i in range(len(queries)): # O(m) query = queries[i] count = self.binarysearch(query, prefix_sum) #O(log n) answer[i] = count return answer def binarysearch( self,v, L): #v = target element low, high = 0, len(L) - 1 while low <= high: mid = (low + high) // 2 if L[mid ] < v: low = mid + 1 elif L[mid ] > v: high = mid - 1 else: return mid + 1 # return the next index than where the element was found return low # Returns index where the element should go if not found 2. Top K Frequent Elements 2.1 Using Dictionaries and Sorting Initialize a dictionary. For every element in nums , you count occurrences of that element. We can do this in a single pass. Plus this has the added benefit of eliminating duplicates, which we will use later. For every unique element from the nums array, create a new 2D array where each element is of the format: [element from nums, it's count] Sort this array based on the counts in descending order. Pick the first k elements. Complexity: \\(O(mlogm)\\) , where \\(m\\) is the number of unique elements in nums . Code: class Solution: def topKFrequent(self, nums: List[int], k: int) -> List[int]: counts = { } # init counts dictionary # count the number of occurrences for each element for num in nums: # O(n) if num in counts: counts[num] += 1 else: counts[num] = 1 # [ [elem1, it's count], [elem2, it's count], [elem3, it's count] ] L = [[x, counts[x]] for x in counts.keys()] # O(m), where m = number of unique elems in nums # Sort in descending order based on counts L.sort(key=lambda x:x[1], reverse=True) # NOT O(n log n), it's O(m log m)! output = [ ] # O(k) # Pick out the top k elements for i in range(k): output.append(L[i][0]) return output 3. Sort Colors This problem is similar to what is discussed in one the practice programming assignments for this week, and we need to solve this problem in \\(O(n)\\) complexity. 3.1 Sort the nums in place We can simply sort the array nums in place are return it. We can use nums.sort() for this. But the comlpexity for this will be: \\(O(n log n)\\) . Can we do better? 3.2 Take Count of Colors We know that there are only three distinct elements in the list. So can we count the occurrences for each distinct color element, and then replace the original array using these counts. For example, consider an array nums = [ 2, 0, 2, 1, 1, 0, 1] . We can keep a dictionary for counts as follows: counts[0] = 2 counts[1] = 3 counts[2] = 2 Then for every color, we can replace nums[i] to nums[i + count] with the color. Code: class Solution: def sortColors(self, nums: List[int]) -> None: \"\"\" Do not return anything, modify nums in-place instead. \"\"\" counts = { 0 : 0, 1: 0, 2: 0 } # O(n). Take counts for each color for i in range(len(nums)): counts[nums[i]] += 1 index = 0 # O(n). For each color, update the nums[i] to nums[i + count] to the color. for i in range(3): for count in range(counts[i]): nums[index] = i index += 1 4. Merge Intervals 4.1 Sorting intervals If we want to merge intervals, it would be easier if overlapping intervals come adjacently in the input list, which means... Sorting! Sort based on the start of the interval. For every interval, check whether start of the interval falls within the end of the merged interval But we will need to consider the below corner cases: One interval subsumes another, then what? This means that the second interval's end is smaller than the first. Such as: [1, 10] and [2, 5] How do you handle last interval? We also need to keep track of the start and the end of the merged intervals. Code: class Solution: def merge(self, intervals: List[List[int]]) -> List[List[int]]: if not intervals: return [] # Sort intervals based on the start intervals.sort(key=lambda x: x[0]) merged_intervals = [] current_start, current_end = intervals[0] for interval in intervals[1:]: # Overlapping intervals, merge them if interval[0] <= current_end: current_end = max(current_end, interval[1]) # The max function is required to handle the 1st edge case else: # Non-overlapping interval found, add previous interval to result merged_intervals.append([current_start, current_end]) # Update current interval current_start, current_end = interval # Add the last interval merged_intervals.append([current_start, current_end]) return merged_intervals","title":"Problems on Sorting and Searching"},{"location":"Sorting%20and%20Searching/Questions/#problems-on-sorting-and-searching","text":"","title":"Problems on Sorting and Searching"},{"location":"Sorting%20and%20Searching/Questions/#1-longest-subsequence-with-limited-sum","text":"","title":"1. Longest Subsequence With Limited Sum"},{"location":"Sorting%20and%20Searching/Questions/#2-top-k-frequent-elements","text":"","title":"2. Top K Frequent Elements"},{"location":"Sorting%20and%20Searching/Questions/#3-sort-colors","text":"","title":"3. Sort Colors"},{"location":"Sorting%20and%20Searching/Questions/#4-merge-intervals","text":"","title":"4. Merge Intervals"},{"location":"Sorting%20and%20Searching/Questions/#1-longest-subsequence-with-limited-sum_1","text":"","title":"1. Longest Subsequence With Limited Sum"},{"location":"Sorting%20and%20Searching/Questions/#11-brute-force","text":"To find out the maximum number of elements less than or equal to some number, just add the smallest numbers. Sort the list first. For every query in queries , find out how many elements can be added by iterating over the array nums . Complexity: $ O(mn) $","title":"1.1: Brute Force"},{"location":"Sorting%20and%20Searching/Questions/#code","text":"class Solution(object): def answerQueries(self, nums, queries): \"\"\" :type nums: List[int] :type queries: List[int] :rtype: List[int] \"\"\" answer = [ 0 for i in range(len(queries))] nums.sort() # Sort so that adding smallest elements is easier for i in range(len(queries)): query = queries[i] index, count, total = 0, 0, 0 # For every query, keep adding the smallest element to get the maximum number of # elements whose total is less than or equal to that query while total <= query and index < len(nums): if total + nums[index] > query: answer[i] = count break else: total += nums[index] index += 1 count += 1 answer[i] = count return answer","title":"Code:"},{"location":"Sorting%20and%20Searching/Questions/#12-prefix-sum","text":"Sort the list first. Keep a prefix_sum array that has this interpretation: i th index stores the sum of first i smallest elements. Note that this array will be sorted. For each queries[i] , use binary search on prefix_sum to find out the largest element less than equal to queries[i] Complexity: \\(O(nlogn)\\)","title":"1.2 Prefix Sum"},{"location":"Sorting%20and%20Searching/Questions/#code_1","text":"class Solution: def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]: answer = [0 for i in range(len(queries))] # O(n) nums.sort() # O(nlogn) prefix_sum = [ ] # O(n) for i in range(len(nums)): prefix_sum.append(nums[0]) if i == 0 else prefix_sum.append(prefix_sum[i - 1] + nums[i]) # O (m log n) for i in range(len(queries)): # O(m) query = queries[i] count = self.binarysearch(query, prefix_sum) #O(log n) answer[i] = count return answer def binarysearch( self,v, L): #v = target element low, high = 0, len(L) - 1 while low <= high: mid = (low + high) // 2 if L[mid ] < v: low = mid + 1 elif L[mid ] > v: high = mid - 1 else: return mid + 1 # return the next index than where the element was found return low # Returns index where the element should go if not found","title":"Code:"},{"location":"Sorting%20and%20Searching/Questions/#2-top-k-frequent-elements_1","text":"","title":"2. Top K Frequent Elements"},{"location":"Sorting%20and%20Searching/Questions/#21-using-dictionaries-and-sorting","text":"Initialize a dictionary. For every element in nums , you count occurrences of that element. We can do this in a single pass. Plus this has the added benefit of eliminating duplicates, which we will use later. For every unique element from the nums array, create a new 2D array where each element is of the format: [element from nums, it's count] Sort this array based on the counts in descending order. Pick the first k elements. Complexity: \\(O(mlogm)\\) , where \\(m\\) is the number of unique elements in nums .","title":"2.1 Using Dictionaries and Sorting"},{"location":"Sorting%20and%20Searching/Questions/#code_2","text":"class Solution: def topKFrequent(self, nums: List[int], k: int) -> List[int]: counts = { } # init counts dictionary # count the number of occurrences for each element for num in nums: # O(n) if num in counts: counts[num] += 1 else: counts[num] = 1 # [ [elem1, it's count], [elem2, it's count], [elem3, it's count] ] L = [[x, counts[x]] for x in counts.keys()] # O(m), where m = number of unique elems in nums # Sort in descending order based on counts L.sort(key=lambda x:x[1], reverse=True) # NOT O(n log n), it's O(m log m)! output = [ ] # O(k) # Pick out the top k elements for i in range(k): output.append(L[i][0]) return output","title":"Code:"},{"location":"Sorting%20and%20Searching/Questions/#3-sort-colors_1","text":"This problem is similar to what is discussed in one the practice programming assignments for this week, and we need to solve this problem in \\(O(n)\\) complexity.","title":"3. Sort Colors"},{"location":"Sorting%20and%20Searching/Questions/#31-sort-the-nums-in-place","text":"We can simply sort the array nums in place are return it. We can use nums.sort() for this. But the comlpexity for this will be: \\(O(n log n)\\) . Can we do better?","title":"3.1 Sort the nums in place"},{"location":"Sorting%20and%20Searching/Questions/#32-take-count-of-colors","text":"We know that there are only three distinct elements in the list. So can we count the occurrences for each distinct color element, and then replace the original array using these counts. For example, consider an array nums = [ 2, 0, 2, 1, 1, 0, 1] . We can keep a dictionary for counts as follows: counts[0] = 2 counts[1] = 3 counts[2] = 2 Then for every color, we can replace nums[i] to nums[i + count] with the color.","title":"3.2 Take Count of Colors"},{"location":"Sorting%20and%20Searching/Questions/#code_3","text":"class Solution: def sortColors(self, nums: List[int]) -> None: \"\"\" Do not return anything, modify nums in-place instead. \"\"\" counts = { 0 : 0, 1: 0, 2: 0 } # O(n). Take counts for each color for i in range(len(nums)): counts[nums[i]] += 1 index = 0 # O(n). For each color, update the nums[i] to nums[i + count] to the color. for i in range(3): for count in range(counts[i]): nums[index] = i index += 1","title":"Code:"},{"location":"Sorting%20and%20Searching/Questions/#4-merge-intervals_1","text":"","title":"4. Merge Intervals"},{"location":"Sorting%20and%20Searching/Questions/#41-sorting-intervals","text":"If we want to merge intervals, it would be easier if overlapping intervals come adjacently in the input list, which means... Sorting! Sort based on the start of the interval. For every interval, check whether start of the interval falls within the end of the merged interval But we will need to consider the below corner cases: One interval subsumes another, then what? This means that the second interval's end is smaller than the first. Such as: [1, 10] and [2, 5] How do you handle last interval? We also need to keep track of the start and the end of the merged intervals.","title":"4.1 Sorting intervals"},{"location":"Sorting%20and%20Searching/Questions/#code_4","text":"class Solution: def merge(self, intervals: List[List[int]]) -> List[List[int]]: if not intervals: return [] # Sort intervals based on the start intervals.sort(key=lambda x: x[0]) merged_intervals = [] current_start, current_end = intervals[0] for interval in intervals[1:]: # Overlapping intervals, merge them if interval[0] <= current_end: current_end = max(current_end, interval[1]) # The max function is required to handle the 1st edge case else: # Non-overlapping interval found, add previous interval to result merged_intervals.append([current_start, current_end]) # Update current interval current_start, current_end = interval # Add the last interval merged_intervals.append([current_start, current_end]) return merged_intervals","title":"Code:"}]}