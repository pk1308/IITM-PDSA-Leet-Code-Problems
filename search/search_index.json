{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/","title":"Leet Code Problems on Arrays, Lists, Stacks, Queues, and Hashing","text":""},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#leet-code-problems-on-arrays-lists-stacks-queues-and-hashing","title":"Leet Code Problems on Arrays, Lists, Stacks, Queues, and Hashing","text":""},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#table-of-contents","title":"\ud83d\udccb Table of Contents:","text":""},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#1-valid-parentheses","title":"1. Valid Parentheses","text":""},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#2-longest-consecutive-sequence","title":"2. Longest Consecutive Sequence","text":""},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#3-rotate-list","title":"3. Rotate List","text":""},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#4-swap-nodes-in-pairs","title":"4. Swap Nodes in Pairs","text":""},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#5-reverse-nodes-in-k-groups","title":"5. Reverse Nodes in K Groups","text":""},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#6-middle-of-the-linked-list","title":"6. Middle of The Linked List","text":""},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#7-delete-the-middle-node","title":"7. Delete the Middle Node","text":""},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#8-delete-nth-node-from-end","title":"8. Delete nth Node From End","text":""},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#9-merge-two-sorted-lists","title":"9. Merge Two Sorted Lists","text":""},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#1-valid-parentheses_1","title":"1. Valid Parentheses","text":""},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#11-using-stacks","title":"1.1 Using Stacks","text":"<p>\ud83d\udd0d Problem Understanding:</p> <p>There are only three types of brackets: <code>[], (), {}</code>. We need to close the last opened bracket first. This implies a Last In, First Out (LIFO) system. Can you think of the appropriate data structure here? Since LIFO behavior is required, a stack is perfect for tracking the parentheses. As we encounter opening parentheses, we add them to the stack. When we see a closing bracket, we remove (pop) the last added one.</p> <p>\ud83e\udd14 Think about this:</p> <p>Imagine you've processed the first two characters of the string and added them to the stack. Your stack might look like this: stack = ['(', '{']. Now, suppose the next character is }. How do you check if this closing bracket matches the last opened one? We can maintain a mapping like this: \\ <code>closing bracket : its corresponding opening bracket</code>. This allows us to verify that each closing bracket properly matches its corresponding opening one.</p> <p>\u26a0\ufe0f Edge Cases:</p> <p>What if there are opening brackets left in the stack, but no more characters in the string? Or vice versa\u2014what if there are closing brackets in the string, but no opening ones left in the stack?</p> <p>Time Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\)</p>"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#code-implementation","title":"\ud83d\udcbb Code Implementation::","text":"<pre><code>class Solution:\n    def isValid(self, s: str) -&gt; bool:\n        # Keep the mapping as 'closing bracket' : 'Correspoding opening bracket'\n        mapping = { \n            ')' : '(', \n            ']' : '[', \n            '}' : '{'\n        }\n\n        stack = [ ]\n\n        # O(n)\n        for char in s:\n            if char not in mapping: # This means that the bracket is an open bracket\n                stack.append(char)  # Simply add the open bracket to the stack     \n            else:\n                # Corner case- stack has no elements but the string has closing bracket\n                if len(stack) == 0:\n                    return False\n\n                # Check if opening bracket in the stack matches with the closing bracket in the string\n                if mapping[char] != stack.pop():\n                    return False\n\n        # if stack is empty after checking every char of string\n        # that means that we found the closing bracket for every opening bracket. Thus, return True\n        # And vice versa. Return False\n\n        return not stack # Returns True if stack is empty, False otherwise\n</code></pre>"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#2-longest-consecutive-sequence_1","title":"2. Longest Consecutive Sequence","text":""},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#21-brute-force","title":"2.1 Brute Force","text":"<ul> <li>For every element, iterate over the array to check if the next element exists in the array. Keep doing this as long as the next element is found.</li> <li>Keep a counter for each sequence, and track the maximum.</li> <li>Time Complexity: \\(O(n^2)\\). But we are told to find an \\(O(n)\\) solution!</li> </ul>"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#22-improved-approach-using-sets","title":"2.2 Improved Approach Using Sets","text":"<p>\ud83e\udde0 Deep Dive:</p> <p>In the brute-force approach, we had to iterate through the entire unsorted array to check if the next element existed. Is there a way to optimize this check? Hint: Consider using a data structure that allows constant-time lookups. </p> <p>We can use set data structure to serve this purpose!</p> <p>How would you solve this using sets? - For each number, while the next consecutive number exists, keep counting. - However, if we use this method directly, some numbers may be checked more than once, leading to \\(O(n^2)\\) time complexity. Can we do better?</p> <p>Which numbers can start a consecutive sequence? - Only those numbers <code>n</code> where <code>n-1</code> is not in the set. Only these numbers can be the starting points of the longest consecutive sequence. Can you see why? - By finding these starting points, we can run our loop efficiently on only these elements. - Time Complexity: \\(O(n)\\) - Space Complexity: \\(O(n)\\)</p>"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#code","title":"Code:","text":"<pre><code>class Solution:\n    def longestConsecutive(self, nums: List[int]) -&gt; int:    \n\n        # Convert nums to a set\n        num_set = set(nums)\n\n        starting_points = set()\n\n        # Only those elements can be starting points where n - 1 is not in num_set\n        # O(n)\n        for num in nums:\n            if num - 1 not in num_set: \n                starting_points.add(num)\n\n        max_length = 0\n        # Overall O(n), because the inner while loop is just going to run once for other elements\n        for current_num in starting_points:\n                current_length = 1\n\n                while current_num + 1 in num_set:\n                    current_num += 1\n                    current_length += 1\n\n                max_length = max(max_length, current_length)\n\n        return max_length\n</code></pre>"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#3-rotate-list_1","title":"3. Rotate List","text":""},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#31-rotation-logic","title":"3.1 \ud83d\udd04 Rotation Logic:","text":"<ul> <li>If \\(k \\gt n\\), then the number of effective rotations is: \\(k = k \\mod n\\). </li> <li>Think about this as a three step problem:<ol> <li>First, traverse \\(k\\) nodes. This <code>n - k</code>th node becomes the <code>newhead</code> of the rotated list.</li> <li>Next, connect the original list's tail to its <code>head</code>to create a cycle in the linked list.</li> <li>Finally, walk from the <code>newhead</code> for <code>n</code> nodes to find the <code>newtail</code>, which will become the tail of the rotated list by marking its next pointer as None.</li> </ol> </li> </ul>"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#code-implementation_1","title":"\ud83d\udcbb Code Implementation::","text":"<pre><code>class Solution:\n    # Gets the length of node: 'n'\n    def get_length(self, head):\n        current = head\n        count = 0\n        while current:\n            current = current.next\n            count += 1        \n        return count\n\n    def rotateRight(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n        n = self.get_length(head)\n\n        # Corner case\n        if n &lt;= 1:\n            return head\n\n        k = k % n # Number of effective rotations\n\n        # In the original list, you need to walk these many steps to get to new head\n        walk_these_many_steps = n - k \n\n        if k == 0 or walk_these_many_steps == 0:\n            return head\n\n        # Get the new head of the list that you will get after you rotate\n        current = head\n        count = 0\n        newhead = None\n        while current:\n            if count == walk_these_many_steps:\n                newhead = current\n                break\n\n            current = current.next\n            count += 1\n\n        # Get to the end of the list so that you can link tail with the head. \n        # But now your linked list is a cycle\n        current = head\n        count = 0\n        while current:\n            if not current.next:\n                current.next = head\n                break\n            current = current.next\n\n        # Now you need to make the new tail point to None to break the cycle\n        current = newhead\n        count = 0\n        while current and count &lt; n:\n            current = current.next\n            count += 1\n            if count == n - 1:\n                current.next = None\n\n        return newhead\n</code></pre>"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#4-swap-nodes-in-pairs_1","title":"4. Swap Nodes in Pairs","text":""},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#5-reverse-nodes-in-k-groups_1","title":"5. Reverse Nodes in K Groups","text":""},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#51-using-recursion","title":"5.1 Using Recursion","text":"<ul> <li>We know how to reverse a linked list from the Graded Assignment question. Given k, we can reverse the first k nodes and return the head and tail of the reversed portion.</li> <li>For the next k nodes, you can pass the kth_node.next as the head and reverse the subsequent k nodes, returning their head and tail. This way, you reverse groups of k nodes. But how do you connect these groups?</li> </ul> <p>\ud83e\udd14 Can you think of a recursive way? - Remember that the last reversed <code>k</code> nodes will be the first to return! - Let's take an example list: <code>1 -&gt; 2 -&gt; 3 -&gt; 4</code>, and <code>k = 2</code>.     - First, reverse <code>1 -&gt; 2</code> as <code>2 -&gt; 1</code>, and return the head as <code>2</code> and tail as <code>1</code>.     - Then, reverse <code>3 -&gt; 4</code> recursively as <code>4 -&gt; 3</code>, and return the head as <code>4</code> and tail as <code>3</code>.     - Now, Now, you just need to connect the tail of the first reversed group (1) to the head of the second reversed group (4). Voil\u00e0! You've connected the reversed groups.</p>"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#code_1","title":"Code:","text":"<pre><code>class Solution:\n    # Helper function: returns the number of nodes in the linked list\n    def get_length(self, head):\n        count = 0\n        current = head\n        while current:\n            current = current.next\n            count += 1\n        return count\n\n    def reverse(self, head, k, n):\n        if not head:\n            return head, None\n\n        # If k &gt; n, then remaining nodes should remain as they are\n        if k &gt; n:\n            return head, None\n\n        # Reverse the K nodes in groups\n        current = head\n        prev = None\n        next_node = None\n        count = 0\n        while current and count &lt;= k:\n            # Counting because we want to mark the tail also\n            if count &lt; k:\n                next_node = current.next\n                current.next = prev       \n                prev = current            \n                current = next_node       \n\n            count += 1\n\n        curr_head = prev # The head of the reversed k nodes\n        curr_tail = head # tail of the reversed k nodes\n\n        # Recursively call reverse on the next k nodes\n        next_head, next_tail = self.reverse(next_node, k, n - k)\n\n        # Connect the current group's tail with the head of the next group\n        curr_tail.next = next_head \n\n        return curr_head, curr_tail\n\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n        n = self.get_length(head)\n        head, tail = self.reverse(head, k, n)\n        return head\n</code></pre>"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#6-middle-of-the-linked-list_1","title":"6. Middle of The Linked List","text":""},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#61-using-iteration","title":"6.1 Using Iteration","text":"<p>How do we find the middle element in an array? We typically compute the middle index as: <code>mid = len(L) // 2</code> and then return <code>L[mid]</code>.</p> <p>Can you find out a similar approach in linked lists? Let's explore this:</p> <ol> <li>First, iterate over the entire list to determine its length.</li> <li>Next, compute the middle index. </li> <li> <p>Finally, traverse the list up to the middle node and return it. </p> </li> <li> <p>Time Complexity: \\(O(n)\\)</p> </li> </ol>"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#code_2","title":"Code:","text":"<pre><code>class Solution:\n    def get_length(self, head):\n        \"\"\"\n        Helper function- iterates over the entire linked list and returns the length of the list\n        \"\"\"\n        counter = 0\n        while head:\n            counter += 1\n            head = head.next\n        return counter\n\n\n    def middleNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        # Handle the base case\n        if not head:\n            return \n\n        # Compute the middle index \n        n = self.get_length(head)\n        mid = n // 2\n\n        # Iterate mid number of steps\n        i = 0\n        while i &lt; mid: \n            head = head.next # note that we are updating the head. So after \"mid\" iterations, head = middle node\n            i+=1\n\n        # Since head = mid after iterating, we return head\n        return head\n</code></pre>"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#7-delete-the-middle-node_1","title":"7. Delete the Middle Node","text":""},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#71-using-iteration","title":"7.1 Using Iteration","text":"<p>We\u2019ve already discussed how to find the middle node in a linked list, right? So, if we know how to reach the middle node, can we figure out how to delete it? \ud83e\udd14</p> <p>To delete a node in a linked list, here\u2019s what we need to do:</p> <ol> <li>Stop at the node before the one we want to delete.</li> <li>Redirect the pointer: Change the next pointer of the current node to skip the node we want to delete and point to the node after it. Essentially, <code>current.next = current.next.next</code>.</li> </ol> <p>\u26a0\ufe0f Edge Cases: What if the linked list has only one node? In this scenario, we need to handle cases where <code>current.next.next</code> doesn\u2019t exist.</p> <ul> <li>Time Complexity: \\(O(n)\\)</li> </ul>"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#code_3","title":"Code:","text":"<pre><code>class Solution:\n    def get_length(self, head):\n        \"\"\"\n        Helper function- iterates over the entire linked list and returns the length of the list\n        \"\"\"\n        counter = 0\n        while head:\n            counter += 1\n            head = head.next\n        return counter\n\n    def deleteMiddle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        mid = self.get_length(head) // 2\n\n        current = head # Iterate using current because we want to return the head\n\n        i = 0\n        # Stopping one node before the middle node\n        while i &lt; mid - 1:\n            current = current.next\n            i += 1\n\n        # Change links of the node before to the next to next node by handling corner case\n        if current.next and current.next.next:\n            current.next = current.next.next\n        else:\n            current.next = None\n        return head\n</code></pre>"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#8-delete-nth-node-from-end_1","title":"8. Delete nth Node From End","text":""},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#81-using-iteration","title":"8.1 Using Iteration","text":"<p>This problem is very similar to the problem of deleting middle node.</p> <p>Observe that deleting the <code>nth</code> node from the end is the same as deleting <code>(length - n)th</code> node from the start. </p> <p>We can use a similar approach as we used in the above question to figure out the solution to this. </p>"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#9-merge-two-sorted-lists_1","title":"9. Merge Two Sorted Lists","text":"<p>This problem is very similar to the <code>merge(A, B)</code> operation from the merge sort. But instead of merging arrays, we\u2019re merging linked lists! \ud83d\udd17</p>"},{"location":"Arrays%2C%20Lists%2C%20Stacks%2C%20Queues%2C%20Hashing/Questions/#code_4","title":"Code:","text":"<pre><code>class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:\n\n        # Dummy node to serve as a proxy for head of the list to return      \n        dummy = ListNode()\n        current = dummy\n\n        # Iterate as long as neither list is exhausted\n        while list1 and list2:\n            if list1.val &lt; list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n\n        # Attach the remaining nodes of list1 or list2\n        if list1:\n            current.next = list1\n        elif list2:\n            current.next = list2\n\n        # The merged list is next to the dummy node\n        return dummy.next\n</code></pre>"},{"location":"Dynamic%20Programming/Questions/","title":"Leet Code Problems Based on Dynamic Programming","text":""},{"location":"Dynamic%20Programming/Questions/#leet-code-problems-based-on-dynamic-programming","title":"Leet Code Problems Based on Dynamic Programming","text":""},{"location":"Dynamic%20Programming/Questions/#1-climbing-stairs","title":"1. Climbing Stairs","text":""},{"location":"Dynamic%20Programming/Questions/#2-house-robber","title":"2. House Robber","text":""},{"location":"Dynamic%20Programming/Questions/#3-fibonacci-numbers","title":"3. Fibonacci Numbers","text":""},{"location":"Dynamic%20Programming/Questions/#4-triangle","title":"4. Triangle","text":""},{"location":"Dynamic%20Programming/Questions/#5-coin-change","title":"5. Coin Change","text":""},{"location":"Dynamic%20Programming/Questions/#1-climbing-stairs_1","title":"1. Climbing Stairs","text":""},{"location":"Dynamic%20Programming/Questions/#11-using-dynamic-programming","title":"1.1 Using Dynamic Programming","text":"<p>Can you find out the recursive approach to this problem? Try to think about the base cases and the the recursive relation. </p> <ul> <li> <p>When you are on the <code>n</code>th step, there are zero ways to reach <code>n</code>th step. If you are on the <code>n-1</code>th step, there is only one way to reach <code>n</code>th step. Lastly, if you are on the <code>n-2</code>th step, there are two ways of reaching the <code>n</code>th step. </p> </li> <li> <p>Further, if you observe, the following relationship holds: $$ ways(k) = ways(k - 1) + ways(k - 2) $$</p> </li> </ul> <p>The number of ways to reach a stair \\(k\\) is the sum of the number of ways to reach the stairs \\(k-1\\) and \\(k-2\\). </p> <p>Can you think of a solution that uses dynamic programming and solves this problem in linear time?</p>"},{"location":"Dynamic%20Programming/Questions/#code","title":"Code:","text":"<pre><code>class Solution:\n    def climbStairs(self, n: int) -&gt; int:\n        L = [0]*n # Initialize the dynamic programming array\n\n        # Base Cases\n        if n == 1: return 1 \n        if n == 2: return 2\n\n        L[0] = 1\n        L[1] = 2\n\n        # ways[i] = ways[i - 1] + ways[i - 2]\n        for i in range(2, n):\n            L[i] = L[i - 1] + L[i - 2]\n\n        # Last element corresponds to the nth stair. So return that value.\n        return L[-1]\n</code></pre>"},{"location":"Dynamic%20Programming/Questions/#2-house-robber_1","title":"2. House Robber","text":""},{"location":"Dynamic%20Programming/Questions/#21-using-dynamic-programming","title":"2.1 Using Dynamic Programming","text":"<p>We cannot break two adjacent houses. That is, <code>nums[i]</code> and <code>nums[i+1]</code> cannot be stolen together. So, for each house, we have to decide whether we should rob it or not. Now, let's think about how we can keep track of the maximum amount of money you can rob up to each house. We could use an array where each element represents the maximum amount of money that can be robbed up to that house. That is, <code>maximum_amount[i]</code> tells us the maximum amount of money that could be stolen up to the house <code>i</code>. </p> <p>What might be the base cases for this <code>maximum_amount</code>, abbreviated as <code>m_a</code>, array? - When it's the first house, then <code>m_a[0]</code> should the amount in the first house.  - When it's the second house, then <code>m_a[1]</code> should be the maximum for <code>nums[0]</code> and <code>nums[1]</code>, since they are adjacent and we cannot rob both. </p> <p>Can you come up with a recursive relation that solves this problem? - From the third house onwards, we can either rob the house or choose to not rob it. If we rob it, we can't rob the previous house. If we don't rob it, we can rob the previous house.  - In our <code>m_a</code> array, we can represent the relation as this:     - $ m_a[i] = max(m_a[i-1], m_a[i-2] + nums[i])$.     - If we don't rob the current house, we are taking the amount stolen up to the previous house.      - If we rob the current house, then we are taking the amount stolen up to the second previous house and adding the amount from the current house to it. </p> <ul> <li>Whatever value we have accumulated till the last house will be the maximum amount that we can steal. </li> <li>Time Complexity: \\(O(n)\\)</li> </ul>"},{"location":"Dynamic%20Programming/Questions/#code_1","title":"Code:","text":"<pre><code>class Solution:\n    def rob(self, nums: List[int]) -&gt; int:\n        if len(nums) == 1:\n            return nums[0]\n\n        maximum_amount = [0] * len(nums)\n\n        # Base cases\n        maximum_amount[0] = nums[0]\n        maximum_amount[1] = max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            maximum_amount[i] = max(maximum_amount[i-1], maximum_amount[i-2] + nums[i])\n\n        return maximum_amount[-1]\n</code></pre>"},{"location":"Dynamic%20Programming/Questions/#3-fibonacci-numbers_1","title":"3. Fibonacci Numbers","text":""},{"location":"Dynamic%20Programming/Questions/#31-using-dynamic-programming","title":"3.1 Using Dynamic Programming","text":"<p>Let's begin by thinking about the problem. We need to calculate the Fibonacci number $F(n) $ for a given \\(n\\). The Fibonacci sequence is defined as:</p> <ul> <li>$ F(0) = 0$</li> <li>\\(F(1) = 1\\)</li> <li>\\(F(n) = F(n-1) + F(n-2) \\text{ for } n &gt; 1\\)</li> </ul> <p>Consider what this means. \\(F(n)\\) is the sum of the two preceding numbers in the sequence. This suggests that if we know \\(F(n-1)\\) and \\(F(n-2)\\), we can find $F(n) $.</p> <p>But how do we approach calculating \\(F(n)\\)?</p> <p>First, think about the simplest cases, \\(F(0)\\) and \\(F(1)\\). These are our base cases because they are defined directly without requiring any further calculations.</p> <p>Now, if \\(n = 2\\), we use the formula \\(F(2) = F(1) + F(0)\\). Since we already know $F(1) = 1 $ and $ F(0) = 0$, we can easily calculate $F(2) = 1 + 0 = 1 $.</p> <p>What if \\(n = 3\\)? Again, using the formula, $F(3) = F(2) + F(1) $. From the previous steps, we know $ F(2) = 1 $ and $F(1) = 1 $, so $F(3) = 1 + 1 = 2 $.</p> <p>Notice that each time we calculate a Fibonacci number, we rely on the results of previous calculations. </p> <p>Now, let\u2019s consider a general approach. If we want to calculate $F(n) $, how can we systematically work our way up from the base cases to $F(n) $?</p> <p>One way is to use recursion. We can define a function that calls itself with smaller values of $  n $ until it reaches the base cases. However, while recursion is elegant, it has a downside\u2014repeatedly solving the same subproblems, which leads to inefficiency.</p> <p>Can we improve this?</p> <p>Yes, we can! Instead of recalculating the same Fibonacci numbers multiple times, we can store the results of each calculation and reuse them when needed.</p> <p>So here's the approach that we will take: - We will define an array named <code>fibtable</code>, where <code>fibtable[i]</code> is the <code>ith</code> number in the fibonacci sequence.  - Observe this relationship: <code>fibtable[i] = fibtable[i - 1] + fibtable[i - 2]</code> - Once we hardcode the base cases, we can iterate over the <code>i</code> upto <code>n</code>, and update the <code>fibtable[i]</code> as per the above update condition. </p>"},{"location":"Dynamic%20Programming/Questions/#code_2","title":"Code:","text":"<pre><code>class Solution:\n    def fib(self, n: int) -&gt; int:\n        # Initialize the fibtable array to be all zeros\n        fibtable = [0] * (n + 1)\n\n        # Base Case 1: Where n == 0\n        if n == 0: return fibtable[0]\n\n        # Base Case 2: Where n == 1\n        fibtable[1] = 1\n\n        for i in range(2, n + 1):\n            #F(n) = F(n - 1) + F(n - 2)\n            fibtable[i] = fibtable[i - 1] + fibtable[i - 2]\n\n        # fibtable[i] is the ith fibonacci number. Thus, to get nth fibonacci number, return fibtable[n]\n        return fibtable[n]\n</code></pre>"},{"location":"Dynamic%20Programming/Questions/#4-triangle_1","title":"4. Triangle","text":""},{"location":"Dynamic%20Programming/Questions/#41-using-dynamic-programming","title":"4.1 Using Dynamic Programming","text":"<p>The question is asking for us to find the minimum path sum from the top to the bottom of the triangle, where each step can be to only the <code>ith</code> or <code>i + 1 th</code> cell in the row below. </p> <p>Can you break this problem into further subproblems? - If we start from the topmost cell of the triangle in the test case 1, the minimum path sum could be described using the following structure: \\(MPS(2) = 2 + min(MPS(3), MPS(4))\\), where $MPS(x) $ tells us the minimum path sum starting from a particular cell in the triangle. More generally,  \\(MPS(triangle[row][col]) = triangle[row][col]+ min(MPS(triangle[row + 1][col]), MPS(triangle[row + 1][col + 1]))\\)</p> <p>Can you identify the base cases here? - The base cases are all the leaf nodes of the triangle where there are no more children. </p> <p>Since we are solving subproblems and then combining those subproblems to solve the original problem, we can use dynamic programming here. Further, using bottom-up approach here might be better than using the top-down approach. </p> <p>After processing the last row, that is- the row of the base cases, we can move one level up in the triangle. After processing that level, we get a minimum path of length 2 for each of the cells in the second last row. More generally, after processing a row, each element in that row would hold the minimum path sum from that element to the bottom of the triangle. After processing the entire triangle, the top element of the triangle would hold the minimum path sum from the top to the bottom of the triangle, which is the answer to the problem.</p> <p>Here's how we can approach the pseudocode: - Start with the second last row. ( We don't need to start from the last row, as the last row is the base case and it will return values just the same as what are there in the cells) - Then for every cell of that row, we apply the following update rule: \\(\\(MPS(triangle[row][col]) = triangle[row][col]+ min(MPS(triangle[row + 1][col]), MPS(triangle[row + 1][col + 1]))\\)\\) - Repeat the same for every row till you reach the topmost row.  - Return the value from the cell at the top- first cell of the first row. </p> <pre><code>class Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -&gt; int:\n        # Start from the second-to-last row of the triangle\n        for row in range(len(triangle) - 2, -1, -1):\n            for col in range(len(triangle[row])):\n                # Update the current element with the sum of the element itself\n                # and the minimum of the two adjacent elements in the row below\n                triangle[row][col] = triangle[row][col] +  min(triangle[row + 1][col], triangle[row + 1][col + 1])\n\n        # The top element now contains the minimum path sum\n        return triangle[0][0]\n</code></pre>"},{"location":"Dynamic%20Programming/Questions/#5-coin-change_1","title":"5. Coin Change","text":""},{"location":"Dynamic%20Programming/Questions/#51-using-dynamic-programming","title":"5.1 Using Dynamic Programming","text":"<p>The first thought here can be that we need to use the greedy strategy. But as we can see from the test cases, the greedy strategy won't always give us the optimal solution. </p> <p>Can you try to break this problem down into subproblems and identify if there are overlapping subproblems? - We can observe that for a given amount, the minimum number of coins needed to get to that amount is one plus the minimum number of coins required to get \\(amount - coin\\). Concisely, we can write this as:     - \\(mincoins(amount) = mincoins(amount - coin) + 1\\) - If you expand the subproblems for every coin in the given test case, you can observe that the subproblems overlap. </p> <p>How can you use dynamic programming to solve this problem? - Since we know the subproblem structure, we can use memoization.  - Keep an array of length \\(amount + 1\\), where each index <code>i</code> stores the minimum number of coins required to get change for amount <code>i</code>. Let this array be called <code>dp</code>. - Initially this array will be set to infinity.  - For each element, we will update the value as:      - <code>dp[i] = min(dp[i], dp[i - coin] + 1)</code>     - We will do this for every amount in <code>range(0, amount + 1)</code>, and we will do this for every <code>coin</code> in the <code>coins</code> array.</p> <p>What can be the base cases here? - To get to amount \\(0\\), we need \\(0\\) coins. Thus, <code>dp[0] = 0</code>.  - Further, for every coin in the given coins array, <code>dp[coin] = 1</code>, as one coin will suffice to get to that amount. </p>"},{"location":"Dynamic%20Programming/Questions/#code_3","title":"Code:","text":"<pre><code>class Solution:\n    def coinChange(self, coins, amount):\n        # Initialize a dp array where dp[i] will hold the minimum number of coins required for amount i\n        dp = [float('inf')] * (amount + 1)\n\n        # Base case: No coins are needed to make amount 0\n        dp[0] = 0\n\n        for coin in coins:\n            dp[coin] = 1\n\n        # Fill the dp array\n        for coin in coins:\n            for x in range(coin, amount + 1):\n                dp[x] = min(dp[x], dp[x - coin] + 1)\n\n        # If dp[amount] is still inf, it means it's not possible to make that amount with given coins\n        return dp[amount] if dp[amount] != float('inf') else -1\n</code></pre>"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/","title":"Leet Code Problems on Graph Algorithms","text":""},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#leet-code-problems-on-graph-algorithms","title":"Leet Code Problems on Graph Algorithms","text":""},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#1-find-the-town-judge","title":"1. Find the Town Judge","text":""},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#2-course-schedule-i","title":"2. Course Schedule-I","text":""},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#3-course-schedule-ii","title":"3. Course Schedule-II","text":""},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#4-snakes-and-ladders","title":"4. Snakes and Ladders","text":""},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#5-sort-items-by-groups-respecting-dependencies","title":"5. Sort Items By Groups Respecting Dependencies","text":""},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#6-find-if-path-exists","title":"6. Find If Path Exists","text":""},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#7-number-of-provinces","title":"7. Number of Provinces","text":""},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#1-find-the-town-judge_1","title":"1. Find the Town Judge","text":""},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#11-by-counting-indegrees","title":"1.1 By Counting Indegrees","text":"<p>We're given the array <code>trusts</code>, where <code>trust[i] = [a_i, b_i]</code> means that <code>a_i_</code> trusts <code>b_i_</code>. Can we convert this problem into a graph problem?</p> <p>If <code>a_i_</code> trusts <code>b_i_</code>, then we can consider it an edge from <code>a_i_</code> to <code>b_i_</code>. </p> <p>The townjudge is a person who: - Trusts no one \\(\\implies outdegree(townjudge) = 0\\) , and - Everyone except him / herself trusts him / her \\(\\implies indegree(townjudge) = n - 1\\).</p> <p>Keep two dictionaries: - To count the indegrees of all the nodes - To count the outdegrees of all the nodes</p> <p>Then for every person, check if its outdegree is \\(0\\) and indegree is \\(n-1\\).</p> <p>Complexity: \\(O(n)\\), since the creating the dictionaries takes \\(O(n)\\) and then iterating over people takes another \\(O(n)\\).</p>"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#code","title":"Code:","text":"<pre><code>class Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -&gt; int:        \n        if n &lt;= 1:\n            return 1\n\n        indegrees = { }\n        outdegrees = { }\n\n        # trust = [a_i, b_i]\n        # a_i -&gt; b_i\n        for a, b in trust:\n            if a not in indegrees: indegrees[a] = 0\n            if b not in indegrees: indegrees[b] = 0\n            if a not in outdegrees: outdegrees[a] = 0\n            if b not in outdegrees: outdegrees[b] = 0\n\n            outdegrees[a] += 1\n            indegrees[b] += 1\n\n        # If indegree == n - 1 and outdegree == 0, then we have found the town judge.\n        townjudge = -1\n        for person in indegrees:\n            if outdegrees[person] == 0:\n                if indegrees[person] &gt;= n - 1:\n                    townjudge = person \n                    break\n        return townjudge        \n</code></pre>"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#2-course-schedule-i_1","title":"2. Course Schedule-I","text":""},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#21-topological-sorting","title":"2.1 Topological Sorting","text":"<p>The <code>prerequisites[i] = [a_i, b_i]</code> \\(\\implies\\) <code>b_i</code> has to come before <code>a_i</code>. In other words, <code>a_i</code> is dependent on <code>b_i</code>. Can you convert this problem into a graph problem? Further, which algorithm do we need to use to find a sequence that satisfies dependencies?</p> <p>If <code>b_i</code> has to come before <code>a_i</code>, then we add an edge from <code>b_i</code> to <code>a_i</code>. Please note the direction of the edge. We can convert this into an adjacency matrix or an adjacency list. For this problem, we are converting the graph into an adjacency matrix. Once we have converted this problem into a graph problem, we can use the algorithm we use when we need to find a sequence that satisfies some dependencies- topological sorting.</p> <p>When would you say that we have successfully found the sequence of courses satisfying the dependencies?  When we the sequence that we get has all the courses- no course is left.  </p>"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#code_1","title":"Code:","text":"<pre><code>class Solution:\n    def preprocessing(self, numCourses, prerequisites) -&gt; list[list[int]]:\n        adjacency_matrix = [ [0 for i in range(numCourses)] for i in range(numCourses) ]\n        for a, b in prerequisites:\n            adjacency_matrix[b][a] = 1\n        return adjacency_matrix\n\n    # Implementation of Topological sort for Adjacency matrix\n    def toposort(self, AMat):\n        #Initialization\n        (rows,cols) = len(AMat), len(AMat[0])\n        indegree = {}\n        toposortlist = []\n\n        #Compute indegree for each vertex\n        for c in range(cols):\n            indegree[c] = 0\n            for r in range(rows):\n                if AMat[r][c] == 1:\n                    indegree[c] = indegree[c] + 1\n\n        # Topological sort Computing process\n        for i in range(rows):\n            # Select the min level vertex for removing the graph which has indegree 0\n            zero_indegree = [k for k in range(cols) if indegree[k] == 0]\n            if not zero_indegree:return toposortlist #Handle the case where there are no more zero indegree vertices\n\n            j = zero_indegree[0]\n            # Store the removed vertex j in toposortlist and reduce the indegree by one \n            toposortlist.append(j)\n            indegree[j] = indegree[j] - 1\n\n            # Reduce the indegree of each adjacent of the removed vertex j by 1\n            for k in range(cols):\n                if AMat[j][k] == 1:\n                    indegree[k] = indegree[k] - 1\n\n        return(toposortlist)\n\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n        adjacency_matrix = self.preprocessing(numCourses, prerequisites)\n        toposortlist = self.toposort(adjacency_matrix)\n        if len(toposortlist) == numCourses: return True\n        return False\n</code></pre>"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#22-topological-sort-better-implementation","title":"2.2 Topological Sort: Better Implementation","text":"<p>The approach used is similar to the above approach. However, we are utilizing better data structures to increase our performance. Instead of keeping an adjacency matrix, we are utilizing a combination of doubly ended queues and adjacency lists. </p> <p>Here's how: - Keep a deque for vertices with zero degree queue such that the insert at end and delete from start operations are both constant time. - Keep a dictionary of indegrees which counts the indegrees for each vertex</p> <p>Complexity: $O(|V| + |E|)</p>"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#code_2","title":"Code:","text":"<pre><code>from collections import deque, Counter\n\nclass Solution:\n    def canFinish(self, numCourse, prerequisites):\n        AList = { i: [] for i in range(numCourse)}\n        indegree = Counter()\n        visited = { i:False for i in range(numCourse)}\n\n        for course, prereq in prerequisites:\n            AList[prereq].append(course)\n            indegree[course] += 1\n\n        # Initialization\n        toposortlist = []\n        zerodegreeq = deque()\n\n        # Find the vertex with indegree 0 and added into the queue\n        for u in range(numCourse):\n            if indegree[u] == 0:\n                zerodegreeq.append(u)\n\n        # Topological sort Computing process\n        while (zerodegreeq):\n            # Remove one vertex from queue which have zero degree vertices\n            curr_vertex = zerodegreeq.popleft()       \n            # Store the removed vertex in toposortlist and reduce the indegree by one \n            toposortlist.append(curr_vertex)\n            indegree[curr_vertex] = indegree[curr_vertex]-1\n\n            # Repeat for each adjacent of the removed vertex\n            for adj_vertex in AList[curr_vertex]:\n                # Reduce the indegree of each adjacent of the removed vertex by 1\n                indegree[adj_vertex] = indegree[adj_vertex] - 1\n                # If after reducing the degree of adjacent, it becomes zero then insert it into the queue\n                if indegree[adj_vertex] == 0:\n                    zerodegreeq.append(adj_vertex)                \n\n        return len(toposortlist) == numCourse\n</code></pre>"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#3-course-schedule-ii_1","title":"3. Course Schedule-II","text":"<p>This problem is an exact replica of the above problem, except that we have to return a sequence that satisfies the dependencies, instead of returning a boolean of whether or not we can create such a sequence. </p> <p>We can use the same approaches discussed in the above question. </p>"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#4-snakes-and-ladders_1","title":"4. Snakes and Ladders","text":""},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#41-using-bfs","title":"4.1 Using BFS","text":"<p>We are given a board with \\(n^2\\) cells. From any particular cell, there can be at maximum only six moves. Can we convert this structure into a graph?</p> <p>For example, in the first test case, assume we are at cell \\(1\\). </p> <p>The next possible moves are: \\(15, 3, 4, 5, 6, 7\\) because \\(2\\) has a ladder to \\(15\\).  From cell \\(1\\), we can make each of the next possible moves as an edge.</p> <p>The task is to find the least number of moves required to reach \\(n^2\\) starting from \\(1\\). Can you identify what type of a problem this is and which algorithm we can use for this problem?</p> <p>It's a shortest path problem without edge weights. The algorithm that we can use for this problem is BFS. </p> <p>Pseudocode: - We first need to convert the board into a graph.      - For every cell, check the next six cells.          - If the cell has a ladder or a snake, then we need to find out where the ladder ends which is given in cell: <code>board[row][col]</code>         - If the cell does not have a ladder or a snake, then <code>board[row][col]</code> will have the vaue \\(-1\\).          - Add the edge as: <code>[cell]</code> to <code>board[row][cell]</code> or the next moves.</p> <ul> <li>Once we have the graph, we can run BFS on this graph, which will return the shortest path. </li> </ul>"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#code_3","title":"Code:","text":""},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#5-sort-items-by-groups-respecting-dependencies_1","title":"5. Sort Items By Groups Respecting Dependencies","text":""},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#51-using-topological-sort","title":"5.1 Using Topological Sort","text":"<p>We need to list a a sequential order of <code>items</code> such that the items belonging to the same group are listed next to each other. Each item can have a dependency such that the other item needs to be completed first- as given in the <code>beforeItems</code> array. It is easy to see that this is a topological ordering problem. </p> <p>Take a moment to think about the following: Let's say we run topological sort directly on the beforeItems. We may pass some test cases. But what test cases might we fail? Whenever we have multiple <code>items</code> that have zero indegree, then we have to make a choice as to which item should we take first. Let's take an example:  </p><pre><code>group[0] = [1, 2]\ngroup[1] = [3, 4]\nindegree[1] = 0\nindegree[3] = 0\nindegree[2] = indegree[4] = 1 \n\nAssume: 2 needs to be come before 4, and 1 needs to come before 2. \n1 -&gt; 2 -&gt; 4\n</code></pre> <p>Now, the issue will come when we are selecting between the <code>items</code> 1 and 3. If our algorithm chooses 3, then all the other elements belonging to group 1 should come next to 3- like: 3, 4-, and only then we'll be able to add elements from group 0- like: 3, 4, 1, 2. This violates the condition that <code>1 -&gt; 2 -&gt; 4</code>.</p> <p>To solve this problem, we need to keep a graph for the <code>groups</code> as well. Whenever we are choosing which <code>item</code> to select for the topological order, we need to first check the <code>groups</code> graph. </p> <p>Thus, we keep two graphs- one for <code>items</code> and one for <code>groups</code>. Then we run a sort of nested topological sort- the outer one for the <code>groups</code> graph, and the inner one for the <code>items</code> graph. This will give us the correct solution that respects both the group dependencies and the item dependencies. </p>"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#psuedocode","title":"Psuedocode:","text":"<ol> <li> <p>Since we are going to need to list all elements belonging to a group side by side, we will keep a dictionary of the format: <code>group:[all items of that group]</code> for easy retrieval.</p> </li> <li> <p>Use <code>beforeItems</code> array to construct both the graphs- <code>groups</code> and <code>items</code>. You can use the either an adjacency matrix or an adjacency list representation for this. Here, we are using Adjacency List representation. </p> <ul> <li>If <code>items[i]</code> needs to come before <code>items[j]</code>, then add edge from <code>i</code> to <code>j</code> for the <code>items_graph</code>. </li> <li>Similarly, for the <code>group_graph</code>, add the edge from <code>group[i]</code> to <code>group[j]</code>, since the item in <code>i</code>th group needs to come before the item in the <code>j</code>th group. </li> </ul> </li> <li> <p>Once you have the graphs, run nested topological sort as mentioned above. </p> </li> </ol>"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#code_4","title":"Code:","text":"<pre><code># Implementation of Queue\nclass Queue:\n    def __init__(self):\n        self.queue = []\n    def enqueue(self,v):\n        self.queue.append(v)\n    def isempty(self):\n        return(self.queue == [])\n    def dequeue(self):\n        v = None\n        if not self.isempty():\n            v = self.queue[0]\n            self.queue = self.queue[1:]\n        return(v)    \n    def __str__(self):\n        return(str(self.queue))\n\nclass Solution:\n    # Creates a dictionary that returns all elements of a particular group. Used in the main algorithm when we are listing all the items # that belong to a group side by side\n    def get_group_wise_elements(self, group, m):\n        group_wise_elements = { i:[] for i in range(m) }\n        for i in range(len(group)):\n            grp = group[i] if group[i] &gt;= 0 else -i-1\n            if grp not in group_wise_elements:\n                group_wise_elements[grp] = []\n            group_wise_elements[grp].append(i)\n        return group_wise_elements\n\n    # Convert the problem into two graphs- group_graph and items_graph. Along with it, return indegrees for each node in both the graphs. \n    def preprocessing(self, beforeItems, group, m, n, groupwise_items):\n        group_indegree, items_indegree = {}, {i:0 for i in range(n)}\n        items_alist =  {i:[] for i in range(n)}\n        group_alist = {}\n\n        for key in groupwise_items:\n            group_alist[key] = set()\n            group_indegree[key] = 0\n\n        for i in range(len(beforeItems)):\n            before = beforeItems[i]\n            for num in before:\n                if num not in items_alist:\n                    items_alist[num] = [ ]\n                items_alist[num].append(i)\n                items_indegree[i] += 1\n\n                grp_num = group[num] if group[num] &gt;= 0 else -num-1\n                grp_i = group[i] if group[i] &gt;= 0 else -i-1  \n                if grp_num != grp_i:\n                    if grp_num not in group_alist:\n                        group_alist[grp_num] = set()\n                    group_alist[grp_num].add(grp_i)\n\n        for key in group_alist.keys():\n            group_alist[key] = list(group_alist[key])\n\n        for u in group_alist.keys():\n            for v in group_alist[u]:\n                if v not in group_indegree:\n                    group_indegree[v] = 0\n                group_indegree[v] += 1\n\n        return items_alist, group_alist, items_indegree, group_indegree\n\n    # Run the actual nested topological sorting algorithm\n    def lpath(self, items_alist, group_alist, items_indegree, group_indegree, groupwise_items, n, group):\n        output = [ ]\n\n        grp_queue = Queue()\n        items_queue = Queue()\n\n        for grp in group_indegree:\n            if group_indegree[grp] == 0:\n                grp_queue.enqueue(grp)\n\n        # Outer topological sort is for groups\n        while not grp_queue.isempty():\n            curr_grp = grp_queue.dequeue()\n            group_indegree[curr_grp] -= 1\n            for adj_grp in group_alist[curr_grp]:\n                # Reduce the indegree of each adjacent group of the removed vertex by 1\n                group_indegree[adj_grp] -= 1\n\n                # If after reducing the degree of adjacent group, it becomes zero then insert it into the group queue\n                if group_indegree[adj_grp] == 0 :\n                    grp_queue.enqueue(adj_grp)\n\n            for i in groupwise_items[curr_grp]:\n                if items_indegree[i] == 0 :\n                    items_queue.enqueue(i)\n\n            # Inner topological sort is for the items\n            while (not items_queue.isempty()):\n\n                # Remove one vertex from items queue which have zero degree items and reduce the indegree by 1\n                curr_vertex = items_queue.dequeue()\n                output.append(curr_vertex)\n                items_indegree[curr_vertex] = items_indegree[curr_vertex] - 1\n\n                # Repeat for each adjacent of the removed item \n                for adj_vertex in items_alist[curr_vertex]:\n                    # Reduce the indegree of each adjacent of the removed item by 1\n                    items_indegree[adj_vertex] = items_indegree[adj_vertex] - 1\n\n                    # If after reducing the degree of adjacent item, it becomes zero then insert it into the items queue\n                    if items_indegree[adj_vertex] == 0 and group[adj_vertex] == curr_grp:\n                        items_queue.enqueue(adj_vertex)\n\n        if len(output) != n: return []\n        return output\n\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -&gt; List[int]:\n        group_wise_items = self.get_group_wise_elements(group, m)\n\n        items_alist, group_alist, items_indegree, group_indegree = self.preprocessing(beforeItems,group, m, n, group_wise_items)\n\n        return self.lpath(items_alist, group_alist, items_indegree, group_indegree, group_wise_items, n, group)\n</code></pre>"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#6-find-if-path-exists_1","title":"6. Find If Path Exists","text":""},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#61-using-bfs","title":"6.1 Using BFS","text":"<p>What is the question asking you to do? - We need to find out whether we can reach a particular destination from the given source node. That is, it's a reachability problem. </p> <p>Can you convert the given <code>edges</code> list into an adjacency list or an adjacency matrix representation? - Each <code>edges[i] = [u_i, v_i]</code> represents a bidirectional edge, which means there is an edge from <code>u</code> to <code>v</code>, and <code>v</code> to <code>u</code>.  - So we can iterate over the entire <code>edges</code> array, and add the two edges for every <code>edges[i]</code>. Here's the code snippet for converting the <code>edges</code> array into an adjacency list: </p><pre><code>for u, v in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n</code></pre> <p>Once we have the adjacency list, which algorithm will give us whether we can reach <code>destination</code> from the <code>source</code>? - We can use either BFS or DFS. For this solution, we are using BFS. </p>"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#code_5","title":"Code:","text":"<p>Note: For a better, more concise code, we have used the <code>deque</code> data structure from the <code>collections</code> module in Python. We can use it to implement a <code>queue</code> used in BFS. </p> <pre><code>from collections import deque\n\nclass Solution:\n    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -&gt; bool:\n        adj_list = { i:[ ] for i in range(n) }\n        visited = set()\n        for u, v in edges:\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n\n        queue = deque([source])\n        visited.add(source)\n        while queue:\n            vertex = queue.popleft()\n            if vertex == destination:\n                return True\n            for neighbor in adj_list[vertex]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n                    visited.add(neighbor)\n        return False\n</code></pre>"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#7-number-of-provinces_1","title":"7. Number of Provinces","text":""},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#71-using-bfs","title":"7.1 Using BFS","text":"<p>We are given a matrix <code>isConnected</code>, whose <code>[i][j]</code>th entry tells us whether there is an undirected edge from <code>i</code> to <code>j</code>. We can interpret this <code>isConnected</code> matrix as an adjacency matrix. </p> <p>A province is a set of vertices that are connected to each other. We are asked to find the number of provinces from the matrix. </p> <p>Can you identify the type of the problem? - The problem is about finding the number of connected components from the graph. </p> <p>Can you identify which algorithm we can use to solve this problem? - We can use BFS or DFS to solve this problem. For this solution, we will use BFS. </p>"},{"location":"Graphs-BFS%2C%20DFS%2C%20Topological%20Sorting/Questions/#code_6","title":"Code:","text":"<pre><code>from collections import deque\n\nclass Solution:\n    def get_neighbors(self, AMat, vertex):\n        \"\"\"Given an adjacency matrix and a vertex, returns all neighbors for that vertex\"\"\"\n        neighbors = []\n        for i in range(len(AMat)):\n            if AMat[vertex][i] == 1:\n                neighbors.append(i)\n        return neighbors\n\n    def BFS(self, AMat, source):\n        \"\"\"\n        Runs BFS from a given source vertex and returns the set of vertices visited in that run of BFS.\n        That is, each run of the BFS will give us one province, or one connected component.\n        \"\"\"\n        visited = set()\n        queue = deque([source])  # Initialize the queue with the source vertex\n        visited.add(source)\n        while queue:\n            vertex = queue.popleft()\n            neighbors = self.get_neighbors(AMat, vertex)  # Pass both AMat and vertex\n            for neighbor in neighbors:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n                    visited.add(neighbor)\n        return visited\n\n    def findCircleNum(self, isConnected):\n\n        # Initially, every vertex gets an invalid component number\n        components = {i: -1 for i in range(len(isConnected))}\n\n        # Keep track of the component number and the number of vertices already visited across BFS runs\n        component_number = 0\n        seen = 0\n\n        while seen &lt; len(isConnected):\n            startv = min([i for i in range(len(isConnected)) if components[i] == -1])\n            visited = self.BFS(isConnected, startv)\n\n            # For every vertex that was visited in the current run of BFS, update its component number and update \n            # the number of vertices seen.\n            for v in visited:\n                components[v] = component_number\n                seen += 1\n\n            # Increment component number such that for the next run of BFS, \n            # a different component number will be assigned\n            component_number += 1\n\n        return component_number \n</code></pre>"},{"location":"Greedy/Questions/","title":"Problems on Greedy Algorithms","text":""},{"location":"Greedy/Questions/#problems-on-greedy-algorithms","title":"Problems on Greedy Algorithms","text":""},{"location":"Greedy/Questions/#1-n-meetings-in-one-room","title":"1. N Meetings in One Room","text":""},{"location":"Greedy/Questions/#2-activity-selection","title":"2. Activity Selection","text":""},{"location":"Greedy/Questions/#3-minimum-number-of-coins","title":"3. Minimum Number of Coins","text":""},{"location":"Greedy/Questions/#4-jump-game","title":"4. Jump Game","text":""},{"location":"Greedy/Questions/#5-jump-game-ii","title":"5. Jump Game-II","text":""},{"location":"Greedy/Questions/#1-n-meetings-in-one-room_1","title":"1. N Meetings in One Room","text":""},{"location":"Greedy/Questions/#11-using-greedy-approach","title":"1.1 Using Greedy Approach","text":"<p>The question is asking us to find out the maximum number of meetings that could be scheduled without conflicts given two arrays- <code>start</code> and <code>end</code>. </p> <p>Can you find out what type of problem this is? - It is a classic interval scheduling problem. </p> <p>The way we go about solving such problems is by sorting the schedules based on their end times and then picking those meetings that don't conflict. </p> <p>Here's how we can approach the solution: - Combine the <code>start</code> and <code>end</code> arrays into a single array of the form: <code>[start_i, end_i]</code> - Sort the list based on the times - Keep track of the end time of the last meet.     - If the start of the current meet overlaps with the previous end time, then we skip the meet.      - Else, we increment the meeting counter, and update the previous end time as the end time of the current meet. </p>"},{"location":"Greedy/Questions/#code","title":"Code:","text":"<pre><code>class Solution:\n    def maximumMeetings(self,n,start,end):\n        # code here\n        times = [ [start[i], end[i]] for i in range(n)]\n\n        # Sort based on end times\n        times.sort(key=lambda x:x[1])\n\n        count = 0\n        prev_endtime = None\n        for start_time, end_time in times:\n            # First meeting\n            if not prev_endtime:\n                prev_endtime = end_time\n                count += 1\n            else:\n                # Check if the previous meet's endtime clashes with the start time of the current meet\n                if prev_endtime &lt; start_time:\n                    prev_endtime = end_time\n                    count += 1\n        return count    \n</code></pre>"},{"location":"Greedy/Questions/#2-activity-selection_1","title":"2. Activity Selection","text":""},{"location":"Greedy/Questions/#21-greedy-approach","title":"2.1 Greedy Approach","text":"<p>Same approach as the above question. </p>"},{"location":"Greedy/Questions/#code_1","title":"Code:","text":"<pre><code>class Solution:\n    def activitySelection(self,n,start,end):\n        # Rearrange the start and end arrays into a single array\n        arr = [ [start[i], end[i]] for i in range(n) ]\n\n        # Sort based on end times\n        arr.sort(key=lambda x:x[1])\n\n        count = 0\n        prev_endtime = None\n        for start_time, end_time in arr:\n            # First activity\n            if not prev_endtime:\n                prev_endtime = end_time\n                count += 1\n            else:\n                # Check if the previous activity's endtime clashes with the start time of the current activity\n                if start_time &gt; prev_endtime:\n                    count += 1\n                    prev_endtime = end_time\n        return count\n</code></pre>"},{"location":"Greedy/Questions/#3-minimum-number-of-coins_1","title":"3. Minimum Number of Coins","text":""},{"location":"Greedy/Questions/#31-using-greedy","title":"3.1 Using Greedy","text":"<p>Note: In general, we cannot guarantee that greedy algorithm will produce correct output. However, in the case of this question, we can use greedy approach. Because the number of smaller denominations is bounded by the fact that we can use larger denominations to represent the smaller denominations. For example, the number of coins of denomination 2 cannot be more than 2, because if their number is 3, then we can replace it with one coin of denomination 5 and one coin of denomination 1. That is, with fewer coins of larger denomination, we can represent more coins of lower denomination. </p> <p>Thus, we can choose a greedy approach: - Keep on subtracting the coin of largest denomination. Then move on to second largest, then third, and so on, till you reach 0.  - Every time you subtract a coin / note, add the denomination to a results array.</p>"},{"location":"Greedy/Questions/#code_2","title":"Code:","text":"<pre><code>class Solution:\n    def minPartition(self, N):\n        denominations = [2000, 500, 200, 100, 50, 20, 10, 5, 2, 1]  # List of denominations in descending order\n        result = []  # List to store the coins/notes used\n\n        for coin in denominations:\n            while N &gt;= coin:  # Check how many times the coin/note can fit into the remaining amount\n                N -= coin  # Subtract the coin/note value from target\n                result.append(coin)  # Add the coin/note to the result list\n\n        return result\n</code></pre>"},{"location":"Greedy/Questions/#4-jump-game_1","title":"4. Jump Game","text":""},{"location":"Greedy/Questions/#41-using-greedy-approach","title":"4.1 Using Greedy Approach","text":"<p>The question is asking us to find out whether the last index can be reached or not using the given <code>nums</code> array. <code>nums[i]</code> corresponds to the maximum jump we can take from the <code>ith</code> index. We can solve this problem using the Greedy Approach. </p> <p>Here's how: - We'll keep a <code>max_jump</code> variable, that acts like a flagpost. It tells what is the maximum index that we can reach based on the values of <code>nums[i]</code> we have seen so far.  - Then we iterate over all the values of <code>nums</code>.     - Whenever this <code>max_index</code> goes beyond the length of the array, we will return <code>True</code>.      - For every value in <code>nums</code>, we update the <code>max_jump</code> as: <code>max_jump = max(max_jump, nums[i] + i)</code>     - But it is also possible that we cannot reach the last index. Consider the example <code>nums = [1, 0, 2]</code>. In this example, once we reach the 1st index, there is no way to move forward. Can we capture this in a condition?         - Whenever <code>i &gt; max_jump</code>, that means we have reached a place from where we cannot proceed further. Thus, we can return <code>False</code> here. </p>"},{"location":"Greedy/Questions/#code_3","title":"Code:","text":"<pre><code>class Solution:\n    def canJump(self, nums: List[int]) -&gt; bool:\n        max_jump = 0\n        for i in range(len(nums)):\n            # i &lt;= max_jump -&gt; case to check [1, 0, 2] like condition\n            # nums[i] + i &gt; max_jump to update the jump\n            if i &lt;= max_jump and nums[i] + i &gt; max_jump :\n                max_jump = nums[i] + i\n\n        # Check whether you can reach the last index or not.\n        return max_jump &gt;= len(nums) - 1\n</code></pre>"},{"location":"Greedy/Questions/#5-jump-game-ii_1","title":"5 Jump Game-II","text":""},{"location":"Greedy/Questions/#using-greedy-approach","title":"Using Greedy Approach","text":""},{"location":"Greedy/Questions/#code_4","title":"Code:","text":"<pre><code>class Solution:\n    def jump(self, nums: List[int]) -&gt; bool:\n        n = len(nums)\n        if n == 1:\n            return 0\n\n        jump_count = 0\n        current_end = 0\n        max_jump = 0\n\n        for i in range(n - 1):\n            max_jump = max(max_jump, i + nums[i])\n\n            # When we reach the end of the current jump. For example, [3, 5, 1, 1, 1, 1]\n            if i == current_end:\n                jump_count += 1\n                current_end = max_jump\n\n                # If we can reach the end, break early\n                if current_end &gt;= n - 1:\n                    break\n\n        return jump_count\n</code></pre>"},{"location":"Heaps%20and%20Trees/Questions/","title":"Leet Code Problems on Heaps and Trees","text":""},{"location":"Heaps%20and%20Trees/Questions/#leet-code-problems-on-heaps-and-trees","title":"Leet Code Problems on Heaps and Trees","text":""},{"location":"Heaps%20and%20Trees/Questions/#1-validate-binary-search-tree","title":"1. Validate Binary Search Tree","text":""},{"location":"Heaps%20and%20Trees/Questions/#2-network-delay-time","title":"2. Network Delay Time","text":""},{"location":"Heaps%20and%20Trees/Questions/#3-maximum-spending-after-buying-items","title":"3. Maximum Spending After Buying Items","text":""},{"location":"Heaps%20and%20Trees/Questions/#1-validate-binary-search-tree_1","title":"1. Validate Binary Search Tree","text":""},{"location":"Heaps%20and%20Trees/Questions/#11-using-inorder-traversal","title":"1.1 Using Inorder Traversal","text":"<p>We know that the inorder traversal of a binary search tree gives a sorted list of elements. Can you try to reason as to why this can be helpful to find out whether we have a valid binary search tree or not?</p> <p>If the tree is a valid binary search tree, then it's inorder traversal will be a valid sorted list.  But on the other hand, if the tree is not a valid binary search tree, then it's inorder traversal will not be a sorted list. </p> <p>So, that's what we do: - Do the inorder traversal on the tree - Go over the elements in the list to check if the list is in a sorted order: Comparing current element with the previous element can be sufficient for this.</p> <p>Time complexity: \\(O(n)\\)</p>"},{"location":"Heaps%20and%20Trees/Questions/#code","title":"Code:","text":"<pre><code>class Solution:\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n\n        tree = self.inorder_traversal(root) # Do inorder traversal\n\n        # Base Case: if tree has just one element, then it is a valid BST\n        if len(tree) &lt;= 1:\n            return True\n\n        # If the list is sorted, then the L[i - 1] will always be smaller than L[i]\n        for i in range(1, len(tree)):\n            if tree[i - 1] &gt;= tree[i]:\n                return False\n        return True\n\n    def inorder_traversal(self, root):\n        if not root:\n            return []\n        return self.inorder_traversal(root.left) + [root.val] + self.inorder_traversal(root.right)     \n</code></pre>"},{"location":"Heaps%20and%20Trees/Questions/#2-network-delay-time_1","title":"2. Network Delay Time","text":""},{"location":"Heaps%20and%20Trees/Questions/#21-using-dijkstra","title":"2.1 Using Dijkstra","text":"<p>We are given an array <code>times</code> where <code>times[i] = [u_i, v_i, w_i]</code>, where <code>u_i</code> is the source node, <code>v_i</code> is the destination and <code>w_i</code> is the weight of that edge. It is clear that this is a directed graph. </p> <p>Can you convert the <code>times</code> array into a more graph suited representation like an adjacency list or an adjacency matrix? - Here's the code snippet that can accomplish this: </p><pre><code>WList = { i:[] for i in range(1, n+1) }\nvisited = {i : False for i in range(1, n+1)}\nfor u, v, w in times:\n    WList[u].append((v, w))\n</code></pre> <p>The question is asking us to find out the minimum time it will take for the signal to reach all nodes if started from the node <code>k</code>. Can you identify what type of a problem this is? - It is a shortest path problem. Since time will be non-negative, we can use Dijkstra here. </p> <p>Observe the following: - The minimum time taken to reach all vertices is the same as the minimum time it would take to \"burn\" the last reached vertex when using Dijkstra. This is the same as the maximum shortest path after running Dijkstra. </p>"},{"location":"Heaps%20and%20Trees/Questions/#code_1","title":"Code:","text":"<pre><code>import heapq\n\nclass Solution:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -&gt; int:\n        # Convert the \"times\" array into an adjacency list\n        WList = { i:[] for i in range(1, n+1) }\n        visited = {i : False for i in range(1, n+1)}\n        for u, v, w in times:\n            WList[u].append((v, w))\n\n\n        # Run Dijkstra on it\n        dist = {node: float('inf') for node in range(1, n+1)}\n        dist[k] = 0\n\n        # Priority queue\n        heap = [(0, k)]  # (distance, node)\n\n        while heap:\n            current_dist, node = heapq.heappop(heap) # By default, heapq.heappop(heap) returns the minimum element from heap\n            visited[node] = True\n            if current_dist &gt; dist[node]:\n                continue\n\n            for neighbor, weight in WList[node]:\n                if visited[neighbor]:\n                    continue\n                distance = current_dist + weight\n                if distance &lt; dist[neighbor]:\n                    dist[neighbor] = distance\n                    heapq.heappush(heap, (distance, neighbor))\n\n        # The minimum time taken for the signal to reach all the vertices, is the same as the last vertex to get \"burnt\" in Dijkstra's algorithm, which is the same as\n        # maximum of shortest distance values\n        max_dist = max(dist.values())\n        return max_dist if max_dist != float('inf') else -1 # Check if all nodes can be reached or not.\n</code></pre>"},{"location":"Heaps%20and%20Trees/Questions/#3-maximum-spending-after-buying-items_1","title":"3 Maximum Spending After Buying Items","text":""},{"location":"Heaps%20and%20Trees/Questions/#31-brute-force","title":"3.1 Brute Force","text":"<p>We are given an \\(m \\times n\\) matrix, and we can take out values only from the right end of each row. Further, the ammount spent on a day is defined as <code>day number * value of the product</code>. </p> <p>To maximize spending over <code>m * n</code> days, can you think of which element do we need to remove first? They should be the minimum elements, because the spending can be maximized if larger values are taken near the end of <code>m * n</code>th day. So, from each rows' last column, we need to pop the one that is the smallest. </p> <p>Here's the pseudocode: - Keep a variable for max spending. - Iterate day counter $ m \\times n$ times     - Keep a minimum value variable.      - For every row, compare the last element of it with this minimum value     - Multiply the minimum with the day counter and add this to the max spending. </p> <p>Time Complexity: \\(O(m^2n)\\)</p>"},{"location":"Heaps%20and%20Trees/Questions/#code_2","title":"Code:","text":"<pre><code>class Solution:\n    def maxSpending(self, values: List[List[int]]) -&gt; int:\n        m, n = len(values), len(values[0])  \n\n        max_spending = 0\n\n        # Iterate over all days\n        for day in range(1, m*n + 1):\n            # Find out the minimum val of the product that can be bought\n            min_val, min_index = float('inf'), None\n            for j in range(m):\n                # Check if the row is not empty\n                # And since only rightmost product can be bought, only compare L[j][-1]th element\n                if values[j] and values[j][-1] &lt; min_val: \n                    min_val = values[j][-1]\n                    min_index = j\n\n            # Pop the minimum value product and add the value to answer\n            product_val = values[min_index].pop()\n            max_spending += day * product_val\n        return max_spending\n</code></pre>"},{"location":"Heaps%20and%20Trees/Questions/#32-using-minheaps","title":"3.2 Using Minheaps","text":"<p>We still need to find the minimum of the rightmost elements and add it to the counter. Can you think of a data structure that lets us efficiently remove the minimum element? Minheaps can be used. </p> <p>Let's see how: Let's assume we have the <code>values</code> array as follows: $$  \\begin{bmatrix} 4 &amp; 3 \\ 7 &amp; 5 \\end{bmatrix} $$</p> <p>The heap will consist of all the rightmost elements: $heap = [ 3, 5] $. From this minheap, we can remove the minimum easily. After <code>delete_min</code> operation, heap looks like: $ heap = [ 5] $ and the matrix <code>values</code> looks like this:</p> \\[  \\begin{bmatrix} 4 \\\\ 7 &amp; 5 \\end{bmatrix} \\] <p>Now, for the first row, the rightmost element is \\(4\\). We need to add it to the minheap for the next iteration for this approach to work well as this: $ heap = [4, 5]$. To do this well, we'll keep track of the row_index to note from which row was this minimum popped.</p> <p>Here's the pseudocode:</p> <ul> <li>Keep the max spending variable</li> <li>Create the minheap for the rightmost elements. </li> <li>Iterate day counter over $ m \\times n$ times</li> <li>Remove the minimum from the Minheap. </li> <li>From the row from which the minimum was popped, insert the new last element in the heap.</li> </ul> <p>Time Complexity: \\(O(mn \\cdot log(m))\\)</p>"},{"location":"Heaps%20and%20Trees/Questions/#code_3","title":"Code:","text":"<pre><code>class Minheap:\n    def __init__(self):\n        self.A = []\n\n    def min_heapify(self,k):\n        l = 2 * k + 1\n        r = 2 * k + 2\n        smallest = k\n        if l &lt; len(self.A) and self.A[l][0] &lt; self.A[smallest][0]:\n            smallest = l\n        if r &lt; len(self.A) and self.A[r][0] &lt; self.A[smallest][0]:\n            smallest = r\n        if smallest != k:\n            self.A[k], self.A[smallest] = self.A[smallest], self.A[k]\n            self.min_heapify(smallest)\n\n    def delete_min(self):\n        item = None\n        if self.A != []:\n            self.A[0],self.A[-1] = self.A[-1],self.A[0]\n            item = self.A.pop()\n            self.min_heapify(0)\n        return item\n\n    def insert_in_minheap(self,d):\n        self.A.append(d)\n        index = len(self.A)-1\n        while index &gt; 0:\n            parent = (index-1)//2\n            if self.A[index][0] &lt; self.A[parent][0]:\n                self.A[index],self.A[parent] = self.A[parent],self.A[index]\n                index = parent\n            else:\n                break\n\nclass Solution:\n    def maxSpending(self, values: List[List[int]]) -&gt; int:\n        m, n = len(values), len(values[0])  \n\n        # Using Priority Queues- O(mn log(m))\n        heap, max_spending = Minheap(), 0\n\n        # Create a minimum heap from the last elements\n        for i in range(m):\n            heap.insert_in_minheap([values[i][-1], i]) # Every elem in heap is: [value, row_number]\n\n        # Iterate over days\n        for day in range(1, m*n+1):\n            min_val, min_store_index = heap.delete_min() # Delete based on value\n            values[min_store_index].pop() # Pop from values array\n            max_spending += day * min_val\n            if values[min_store_index]:\n                heap.insert_in_minheap([values[min_store_index][-1], min_store_index])\n\n        return max_spending\n</code></pre>"},{"location":"Shortest%20Paths%20and%20Minimum%20Spanning%20Trees/Questions/","title":"Leet Code Problems on Shortest Path and Minimum Cost Spanning Trees","text":""},{"location":"Shortest%20Paths%20and%20Minimum%20Spanning%20Trees/Questions/#leet-code-problems-on-shortest-path-and-minimum-cost-spanning-trees","title":"Leet Code Problems on Shortest Path and Minimum Cost Spanning Trees","text":""},{"location":"Shortest%20Paths%20and%20Minimum%20Spanning%20Trees/Questions/#1-min-cost-to-connect-all-points","title":"1. Min Cost To Connect All Points","text":""},{"location":"Shortest%20Paths%20and%20Minimum%20Spanning%20Trees/Questions/#2-cheapest-flight-within-k-stops","title":"2. Cheapest Flight Within K Stops","text":""},{"location":"Shortest%20Paths%20and%20Minimum%20Spanning%20Trees/Questions/#1-min-cost-to-connect-all-points_1","title":"1. Min Cost To Connect All Points","text":""},{"location":"Shortest%20Paths%20and%20Minimum%20Spanning%20Trees/Questions/#11-minimum-cost-spanning-trees","title":"1.1 Minimum Cost Spanning Trees","text":"<ul> <li>The question is asking for the minimum cost to connect all the points. Can you identify what type of a problem this is? It is a MCST problem!</li> <li>How can you convert the given points into a graph? Each point can represent a node in the graph. The edges are the distances between any two points in the graph. So, it will be a complete graph- where each node is connected to every other node with some cost.</li> <li> <p>Run a nested loop:</p> <ul> <li>For each point<ul> <li>For every other point, <ul> <li>Compute the distance and store the edge in an adjacency matrix or an adjacency list</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Once we have the graph representation, we can run either or Prim's or Kruskal's algorithm on this graph to get the Minimum Cost Spanning Tree's edges. </p> </li> <li>To compute the minimum cost, iterate over the Tree edges and sum the edge weights</li> </ul>"},{"location":"Shortest%20Paths%20and%20Minimum%20Spanning%20Trees/Questions/#code","title":"Code:","text":"<pre><code>def kruskal(WList):\n    \"\"\"Kruskal's as per the PDSA book\"\"\"\n    (edges,component,TE) = ([],{},[])\n    for u in WList.keys():\n        edges.extend([(d,u,v) for (v,d) in WList[u]])\n        component[u] = u\n\n    edges.sort()\n\n    for (d,u,v) in edges:\n        if component[u] != component[v]:\n            TE.append((u,v, d))\n            c = component[u]\n            for w in WList.keys():\n                if component[w] == c:\n                    component[w] = component[v]\n\ndef compute_min_cost(TE) -&gt; int:\n    # Compute the Minimum Cost based on Tree Edges\n    min_cost = 0\n    for u, v, d in TE:\n        min_cost += d\n    return(min_cost)\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -&gt; int:\n        # Init Adjacency Matrix\n        AList = { i : [] for i in range(len(points))}\n\n        # Each point can be connected to every other point and their manhattan distance can be computed.\n        for i in range(len(points)):\n            x1, y1 = points[i][0], points[i][1]\n            for j in range(i + 1, len(points)):\n                x2, y2 = points[j][0], points[j][1]\n                dist = abs(x1 - x2) + abs(y1 - y2)\n\n                # Distance from point i to j is same as from j to i. So init both entries\n                AList[i].append((j, dist))\n                AList[j].append((i, dist))\n\n        tree_edges = kruskal(AList)\n        minimum_cost = compute_min_cost(tree_edges)\n        return minimum_cost\n</code></pre>"},{"location":"Shortest%20Paths%20and%20Minimum%20Spanning%20Trees/Questions/#2-cheapest-flight-within-k-stops_1","title":"2. Cheapest Flight Within K Stops","text":""},{"location":"Shortest%20Paths%20and%20Minimum%20Spanning%20Trees/Questions/#21-using-bellman-ford","title":"2.1 Using Bellman-Ford","text":""},{"location":"Sorting%20and%20Searching/Questions/","title":"Problems on Sorting and Searching","text":""},{"location":"Sorting%20and%20Searching/Questions/#problems-on-sorting-and-searching","title":"Problems on Sorting and Searching","text":""},{"location":"Sorting%20and%20Searching/Questions/#1-longest-subsequence-with-limited-sum","title":"1. Longest Subsequence With Limited Sum","text":""},{"location":"Sorting%20and%20Searching/Questions/#2-top-k-frequent-elements","title":"2. Top K Frequent Elements","text":""},{"location":"Sorting%20and%20Searching/Questions/#3-sort-colors","title":"3. Sort Colors","text":""},{"location":"Sorting%20and%20Searching/Questions/#4-merge-intervals","title":"4. Merge Intervals","text":""},{"location":"Sorting%20and%20Searching/Questions/#1-longest-subsequence-with-limited-sum_1","title":"1. Longest Subsequence With Limited Sum","text":""},{"location":"Sorting%20and%20Searching/Questions/#11-brute-force","title":"1.1: Brute Force","text":"<ul> <li>To find out the maximum number of elements less than or equal to some number, just add the smallest numbers. </li> <li>Sort the list first.</li> <li>For every query in <code>queries</code>, find out how many elements can be added by iterating over the array <code>nums</code>.</li> <li>Complexity: $ O(mn) $</li> </ul>"},{"location":"Sorting%20and%20Searching/Questions/#code","title":"Code:","text":"<pre><code>class Solution(object):\n    def answerQueries(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        answer = [ 0 for i in range(len(queries))]\n        nums.sort() # Sort so that adding smallest elements is easier\n\n        for i in range(len(queries)):\n            query = queries[i]\n            index, count, total = 0, 0, 0\n\n            # For every query, keep adding the smallest element to get the maximum number of \n            # elements whose total is less than or equal to that query\n            while total &lt;= query and index &lt; len(nums):\n                if total + nums[index] &gt; query:\n                    answer[i] = count\n                    break\n                else:\n                    total += nums[index]\n                    index += 1\n                    count += 1\n            answer[i] = count\n        return answer\n</code></pre>"},{"location":"Sorting%20and%20Searching/Questions/#12-prefix-sum","title":"1.2 Prefix Sum","text":"<ul> <li>Sort the list first. </li> <li>Keep a <code>prefix_sum</code> array that has this interpretation: <code>i</code>th index stores the sum of first <code>i</code> smallest elements. Note that this array will be sorted.</li> <li>For each <code>queries[i]</code>, use binary search on <code>prefix_sum</code> to find out the largest element less than equal to <code>queries[i]</code></li> <li>Complexity: \\(O(nlogn)\\)</li> </ul>"},{"location":"Sorting%20and%20Searching/Questions/#code_1","title":"Code:","text":"<pre><code>class Solution:\n    def answerQueries(self, nums: List[int], queries: List[int]) -&gt; List[int]:\n        answer = [0 for i in range(len(queries))] # O(n)\n        nums.sort() # O(nlogn)\n        prefix_sum = [ ] \n\n        # O(n)\n        for i in range(len(nums)):\n            prefix_sum.append(nums[0]) if i == 0 else prefix_sum.append(prefix_sum[i - 1] + nums[i])\n\n        # O (m log n)\n        for i in range(len(queries)): # O(m)\n            query = queries[i]\n            count = self.binarysearch(query, prefix_sum) #O(log n)\n            answer[i] = count\n        return answer\n\n\n    def binarysearch( self,v, L):  #v = target element\n        low, high = 0, len(L) - 1\n        while low &lt;= high: \n            mid = (low + high) // 2\n            if L[mid ] &lt; v:\n                low = mid  + 1\n            elif L[mid ] &gt; v:\n                high = mid  - 1\n            else:\n                return mid + 1 # return the next index than where the element was found\n        return low # Returns index where the element should go if not found\n</code></pre>"},{"location":"Sorting%20and%20Searching/Questions/#2-top-k-frequent-elements_1","title":"2. Top K Frequent Elements","text":""},{"location":"Sorting%20and%20Searching/Questions/#21-using-dictionaries-and-sorting","title":"2.1 Using Dictionaries and Sorting","text":"<ul> <li>Initialize a dictionary. For every element in <code>nums</code>, you count occurrences of that element. We can do this in a single pass. Plus this has the added benefit of eliminating duplicates, which we will use later. </li> <li>For every unique element from the <code>nums</code> array, create a new 2D array where each element is of the format: <code>[element from nums, it's count]</code></li> <li>Sort this array based on the counts in descending order. </li> <li>Pick the first <code>k</code> elements.</li> <li>Complexity: \\(O(mlogm)\\), where \\(m\\) is the number of unique elements in <code>nums</code>.</li> </ul>"},{"location":"Sorting%20and%20Searching/Questions/#code_2","title":"Code:","text":"<pre><code>class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:\n        counts = { } # init counts dictionary\n\n        # count the number of occurrences for each element\n        for num in nums: # O(n)\n            if num in counts:\n                counts[num] += 1 \n            else:\n                counts[num] = 1\n\n        # [ [elem1, it's count], [elem2, it's count], [elem3, it's count] ]\n        L = [[x, counts[x]] for x in counts.keys()] # O(m), where m = number of unique elems in nums\n\n        # Sort in descending order based on counts\n        L.sort(key=lambda x:x[1], reverse=True) # NOT O(n log n), it's O(m log m)!\n\n        output = [ ]\n\n        # O(k)\n        # Pick out the top k elements\n        for i in range(k):\n            output.append(L[i][0])\n\n        return output\n</code></pre>"},{"location":"Sorting%20and%20Searching/Questions/#3-sort-colors_1","title":"3. Sort Colors","text":"<p>This problem is similar to what is discussed in one the practice programming assignments for this week, and we need to solve this problem in \\(O(n)\\) complexity. </p>"},{"location":"Sorting%20and%20Searching/Questions/#31-sort-the-nums-in-place","title":"3.1 Sort the <code>nums</code> in place","text":"<p>We can simply sort the array <code>nums</code> in place are return it. We can use <code>nums.sort()</code> for this. But the comlpexity for this will be: \\(O(n log n)\\). Can we do better?</p>"},{"location":"Sorting%20and%20Searching/Questions/#32-take-count-of-colors","title":"3.2 Take Count of Colors","text":"<p>We know that there are only three distinct elements in the list. So can we count the occurrences for each distinct color element, and then replace the original array using these counts.  For example, consider an array <code>nums = [ 2, 0, 2, 1, 1, 0, 1]</code>. We can keep a dictionary for counts as follows:  </p><pre><code>counts[0] = 2\ncounts[1] = 3\ncounts[2] = 2\n</code></pre> <p>Then for every color, we can replace <code>nums[i]</code> to <code>nums[i + count]</code> with the color.</p>"},{"location":"Sorting%20and%20Searching/Questions/#code_3","title":"Code:","text":"<pre><code>class Solution:\n    def sortColors(self, nums: List[int]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        counts = { \n            0 : 0, \n            1: 0, \n            2: 0\n        }\n\n        # O(n). Take counts for each color\n        for i in range(len(nums)):\n            counts[nums[i]] += 1\n\n        index = 0\n\n        # O(n). For each color, update the nums[i] to nums[i + count] to the color.\n        for i in range(3):\n            for count in range(counts[i]):\n                nums[index] = i\n                index += 1\n</code></pre>"},{"location":"Sorting%20and%20Searching/Questions/#4-merge-intervals_1","title":"4. Merge Intervals","text":""},{"location":"Sorting%20and%20Searching/Questions/#41-sorting-intervals","title":"4.1  Sorting intervals","text":"<ul> <li>If we want to merge intervals, it would be easier if overlapping intervals come adjacently in the input list, which means... Sorting!</li> <li>Sort based on the start of the interval. </li> <li> <p>For every interval, check whether start of the interval falls within the end of the merged interval</p> </li> <li> <p>But we will need to consider the below corner cases:</p> <ul> <li>One interval subsumes another, then what? This means that the second interval's end is smaller than the first.  Such as: [1, 10] and [2, 5]</li> <li>How do you handle last interval?</li> </ul> </li> </ul> <p>We also need to keep track of the start and the end of the merged intervals.</p>"},{"location":"Sorting%20and%20Searching/Questions/#code_4","title":"Code:","text":"<pre><code>class Solution:\n    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:\n        if not intervals:\n            return []\n\n        # Sort intervals based on the start\n        intervals.sort(key=lambda x: x[0])\n\n        merged_intervals = []\n        current_start, current_end = intervals[0]\n\n        for interval in intervals[1:]:\n            # Overlapping intervals, merge them\n            if interval[0] &lt;= current_end:\n                current_end = max(current_end, interval[1]) # The max function is required to handle the 1st edge case\n            else:\n                # Non-overlapping interval found, add previous interval to result\n                merged_intervals.append([current_start, current_end])\n\n                # Update current interval\n                current_start, current_end = interval\n\n        # Add the last interval\n        merged_intervals.append([current_start, current_end])\n\n        return merged_intervals\n</code></pre>"}]}